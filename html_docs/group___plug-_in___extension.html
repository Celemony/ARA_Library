<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARA SDK 1.9.14: Plug-In Extension</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="DoxygenStyleSheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ARA_Logo.png" height="50px"/></td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___plug-_in___extension.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Subpages</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Plug-In Extension<div class="ingroups"><a class="el" href="group___plug___in___interfaces.html">Plug-In Interfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The plug-in extension provides ARA-specific additional functionality per companion plug-in instance. On a conceptual level, the plug-in extension is not an object of its own, but merely a set of additional interfaces of the companion plug-in instance, augmenting it with a few ARA-specific features in a fashion that is independent from the actual companion API in use. Accordingly, it is coupled 1:1 to the companion plug-in instance and its lifetime matches the lifetime of the companion plug-in instance (no separate destruction function needed). Along the same lines, plug-in extensions themselves are not persistent.  <br>                               The plug-in extension is exposed towards the host when it binds a plug-in instance as created by the companion APIs to a specific ARA model graph, represented by its associated document controller. This setup call is executed via a vendor-specific extension of the companion API and may only be made once. It shifts the "normal" companion plug-in into the ARA world, and once established, this coupling cannot be undone. When ARA is enabled, the renderer behavior has slightly different semantics compared to the non-ARA use case. Since ARA renderers are essentially generators that use non-realtime data to generate realtime signals, they do not use the realtime input signal for processing. Playback renderers will simply ignore their inputs, but editor renderers will always add their output signal to the input signal provided by the host. If a plug-in assumes both rendering roles, playback rendering will already ignore the inputs, so the editor rendering will directly add to the playback output, not to the input.  <br>                               Since ARA 2.0, the host can explicitly establish the roles that the given instance will assume in its specific implementation upon binding the plug-in instance to the ARA document controller. Each role is associated with a dedicated feature set that only is available when the particular role has been established. Depending on the chosen roles, the following calls control which playback regions are to be rendered according to which rule. Separating roles allows for more flexible ARA integrations and optimizes resource usage. A host could for example use a playback renderer plug-in instance playback region, plus one plug-in instance per track for editor rendering and viewing all regions on that track. Amongst other behavior, the roles heavily affect the relationship between plug-in instances and playback regions. For rendering, each plug-in extension can handle multiple playback regions if desired, albeit the semantics for modifying the set of associated regions per renderer are somewhat different between playback and editor renderers, see below. For editor view purposes, the relationship is not explicit to accommodate for a very broad range of user interface concepts that need to interact with the API. Generally, each editor view is associated with all playback regions in the document controller to which the plug-in is bound. However, typically only a varying subset of those regions will be shown at any point in time, depending on the intrinsic feature set of the plug-in, and reflecting the selection that the user has performed in the host - see notifySelection(). </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Subpages</h2></td></tr>
<tr class="memitem:group___playback___renderer___interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___playback___renderer___interface.html">Playback Renderer Interface (added in ARA 2.0)</a></td></tr>
<tr class="memdesc:group___playback___renderer___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group___plug-_in___extension.html#ggadb888a1dc7f658281705411c7b4c253ea5f7f13e0744f8a3b1a0167aef4cc91ca" title="Role: playback render. Plug-in instances fulfilling this role are performing playback rendering,...">kARAPlaybackRendererRole</a>.  <br>                               Plug-in developers using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_playback_renderer_interface" title="Base class for implementing ARAPlaybackRendererInterface.">ARA::PlugIn::PlaybackRendererInterface</a>, or extend the already implemented <a class="el" href="group___a_r_a___library___a_r_a_plug___plug_in_instance_roles.html#class_a_r_a_1_1_plug_in_1_1_playback_renderer" title="Extensible plug-in instance role class implementing an ARA Playback Renderer Interface (added in ARA ...">ARA::PlugIn::PlaybackRenderer</a> class as needed. For host developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interface___wrappers.html#class_a_r_a_1_1_host_1_1_playback_renderer" title="Wrapper class for the ARAPlaybackRendererInterface provided by the plug-in.">ARA::Host::PlaybackRenderer</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___editor___renderer___interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___editor___renderer___interface.html">Editor Renderer Interface (added in ARA 2.0)</a></td></tr>
<tr class="memdesc:group___editor___renderer___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group___plug-_in___extension.html#ggadb888a1dc7f658281705411c7b4c253ea43bac0cdb9433838cab4b79734aa4486" title="Role: editor render. Plug-in instances fulfilling this role are performing auxiliary realtime renderi...">kARAEditorRendererRole</a>.  <br>                               Plug-in developers using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_editor_renderer_interface" title="Base class for implementing ARAEditorRendererInterface.">ARA::PlugIn::EditorRendererInterface</a>, or extend the already implemented <a class="el" href="group___a_r_a___library___a_r_a_plug___plug_in_instance_roles.html#class_a_r_a_1_1_plug_in_1_1_editor_renderer" title="Extensible plug-in instance role class implementing an ARA Editor Renderer Interface (added in ARA 2....">ARA::PlugIn::EditorRenderer</a> class as needed. For host developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interface___wrappers.html#class_a_r_a_1_1_host_1_1_editor_renderer" title="Wrapper class for the ARAEditorRendererInterface provided by the plug-in.">ARA::Host::EditorRenderer</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___editor___view___interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___editor___view___interface.html">Editor View Interface (added in ARA 2.0)</a></td></tr>
<tr class="memdesc:group___editor___view___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group___plug-_in___extension.html#ggadb888a1dc7f658281705411c7b4c253eac033ffe4d4ae6821fe05a418929cf093" title="Role: editor view. Plug-in instances fulfilling this role can be used to display a GUI....">kARAEditorViewRole</a>.  <br>                               Users will often reconfigure the plug-in view through scrolling, zooming, navigating lists of entities, etc. to select the subset of ARA entities that they currently need to view or edit. Those selection features can be implemented in the plug-in (which was the only available solution in ARA 1). However, the host applications already have established user workflows for selecting their representations of the ARA objects. Making those workflows available to the plug-ins is leads to a much more consistent, streamlined user experience. Since the views are implemented through the companion API, there is no matching ARA entity yet. Instead, the companion plug-in instance is used as a controller for its associated view. (Note that while some companion APIs allow for multiple views of a given plug-in used at the same time, this is not recommended when using ARA editor views.) These calls only affect views, not the audio rendering. They only should be made while the plug-in is showing its UI, or before entering this state (i.e. during GUI setup phase), in order to optimize resource usage. Accordingly, the host should send an update of the selection when (re-)opening an ARA plug-in view. These calls also may be made while changes are being made to the model graph (i.e. inside of pairs of <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">ARADocumentControllerInterface::beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document.">ARADocumentControllerInterface::endEditing()</a>).  <br>                               Plug-in developers using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_editor_view_interface" title="Base class for implementing ARAEditorViewInterface.">ARA::PlugIn::EditorViewInterface</a>, or extend the already implemented <a class="el" href="group___a_r_a___library___a_r_a_plug___plug_in_instance_roles.html#class_a_r_a_1_1_plug_in_1_1_editor_view" title="Extensible plug-in instance role class implementing an ARA Editor View Interface (added in ARA 2....">ARA::PlugIn::EditorView</a> class as needed. For host developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interface___wrappers.html#class_a_r_a_1_1_host_1_1_editor_view" title="Wrapper class for the ARAEditorViewInterface provided by the plug-in.">ARA::Host::EditorView</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___plug-_in___extension___interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___extension___interface.html">Deprecated: Plug-In Extension Interface.</a></td></tr>
<tr class="memdesc:group___plug-_in___extension___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface was used before ARA 2.0 defined dedicated plug-in roles. It is only to be implemented when ARA 1 backwards compatibility is desired. An ARA 1 call to set/removePlaybackRegion() in this interface is equivalent to calling both set/removePlaybackRegion() in <a class="el" href="group___playback___renderer___interface.html#struct_a_r_a_playback_renderer_interface" title="Plug-in interface: playback renderer. The function pointers in this struct must remain valid until th...">ARAPlaybackRendererInterface</a> and add/removePlaybackRegion() in <a class="el" href="group___editor___renderer___interface.html#struct_a_r_a_editor_renderer_interface" title="Plug-in interface: editor renderer. The function pointers in this struct must remain valid until the ...">ARAEditorRendererInterface</a>. To some extend ARA 1 also uses this to for tasks now associated with <a class="el" href="group___editor___view___interface.html#struct_a_r_a_editor_view_interface" title="Plug-in interface: view controller. The function pointers in this struct must remain valid until the ...">ARAEditorViewInterface</a>: opening the UI of an ARA 1 plug-in instance is interpreted as selection of the playback region set via this interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:struct_a_r_a_plug_in_extension_instance"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___extension.html#struct_a_r_a_plug_in_extension_instance">ARAPlugInExtensionInstance</a></td></tr>
<tr class="memdesc:struct_a_r_a_plug_in_extension_instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">The plug-in extension instance struct and all interfaces and refs therein must remain valid until the companion plug-in is destroyed by the host. Note that the companion plug-in destruction may happen before or after destroying the document controller it has been bound to, plug-ins must handle both possible destruction orders. Plug-ins must provide all interfaces that have been requested by the host through the role assignment, and suppress interfaces explicitly excluded by the roles - e.g. if the host did not assign kARAEditorRendererRole even it was known, editorRendererInterface will be NULL.  <a href="group___plug-_in___extension.html#struct_a_r_a_plug_in_extension_instance">More...</a><br /></td></tr>
<tr class="separator:struct_a_r_a_plug_in_extension_instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_a_r_a_plug_in_extension_instance" id="struct_a_r_a_plug_in_extension_instance"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_a_r_a_plug_in_extension_instance">&#9670;&nbsp;</a></span>ARAPlugInExtensionInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ARAPlugInExtensionInstance</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The plug-in extension instance struct and all interfaces and refs therein must remain valid until the companion plug-in is destroyed by the host. Note that the companion plug-in destruction may happen before or after destroying the document controller it has been bound to, plug-ins must handle both possible destruction orders. Plug-ins must provide all interfaces that have been requested by the host through the role assignment, and suppress interfaces explicitly excluded by the roles - e.g. if the host did not assign kARAEditorRendererRole even it was known, editorRendererInterface will be NULL. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Size-based struct versioning</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8272db3aa4580fe6b7beb9697d0787b7"></a> See <a class="el" href="group___versioned__structs.html">Versioned structs</a>. </p>
</td></tr>
<tr class="memitem:a489fd476545f685bcd1af345746a1e63"><td class="memItemLeft" align="right" valign="top"><a id="a489fd476545f685bcd1af345746a1e63"></a>
<a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>structSize</b></td></tr>
<tr class="separator:a489fd476545f685bcd1af345746a1e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915576132116535c90819b2633f0e026"><td class="memItemLeft" align="right" valign="top"><a id="a915576132116535c90819b2633f0e026"></a>
ARAPlugInExtensionRef&#160;</td><td class="memItemRight" valign="bottom"><b>plugInExtensionRef</b></td></tr>
<tr class="separator:a915576132116535c90819b2633f0e026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedc6ab41e91f0efc2f3286b1db4c97a"><td class="memItemLeft" align="right" valign="top"><a id="aeedc6ab41e91f0efc2f3286b1db4c97a"></a>
const ARAPlugInExtensionInterface *&#160;</td><td class="memItemRight" valign="bottom"><b>plugInExtensionInterface</b></td></tr>
<tr class="separator:aeedc6ab41e91f0efc2f3286b1db4c97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>ARA2 Instance Roles</h3></td></tr>
<tr class="memitem:ac776823604435eb58b180608d7948908"><td class="memItemLeft" align="right" valign="top"><a id="ac776823604435eb58b180608d7948908"></a>
<a class="el" href="group___playback___renderer___interface.html#ga039bd55c831ffd956494bf7ec3103c56">ARAPlaybackRendererRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>playbackRendererRef</b></td></tr>
<tr class="separator:ac776823604435eb58b180608d7948908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06c5fa11b08c456d51b67e3ce367bcd"><td class="memItemLeft" align="right" valign="top"><a id="ab06c5fa11b08c456d51b67e3ce367bcd"></a>
const <a class="el" href="group___playback___renderer___interface.html#struct_a_r_a_playback_renderer_interface">ARAPlaybackRendererInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>playbackRendererInterface</b></td></tr>
<tr class="separator:ab06c5fa11b08c456d51b67e3ce367bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa27887681be47bdfbe8bc166698b10"><td class="memItemLeft" align="right" valign="top"><a id="abfa27887681be47bdfbe8bc166698b10"></a>
<a class="el" href="group___editor___renderer___interface.html#ga5dc4f0e1f58ea8f57787f96d0ce4f397">ARAEditorRendererRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>editorRendererRef</b></td></tr>
<tr class="separator:abfa27887681be47bdfbe8bc166698b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7cb10fefb35a7bc5f8a1d1758deaf3"><td class="memItemLeft" align="right" valign="top"><a id="a3e7cb10fefb35a7bc5f8a1d1758deaf3"></a>
const <a class="el" href="group___editor___renderer___interface.html#struct_a_r_a_editor_renderer_interface">ARAEditorRendererInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>editorRendererInterface</b></td></tr>
<tr class="separator:a3e7cb10fefb35a7bc5f8a1d1758deaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3325950859b7342de263fa220003c15"><td class="memItemLeft" align="right" valign="top"><a id="ae3325950859b7342de263fa220003c15"></a>
<a class="el" href="group___editor___view___interface.html#ga5937ae1c0b7171a93481e19fa1da46ac">ARAEditorViewRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>editorViewRef</b></td></tr>
<tr class="separator:ae3325950859b7342de263fa220003c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565ffc4e8cef8af85e6ffe30b6672ee6"><td class="memItemLeft" align="right" valign="top"><a id="a565ffc4e8cef8af85e6ffe30b6672ee6"></a>
const <a class="el" href="group___editor___view___interface.html#struct_a_r_a_editor_view_interface">ARAEditorViewInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>editorViewInterface</b></td></tr>
<tr class="separator:a565ffc4e8cef8af85e6ffe30b6672ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gadb888a1dc7f658281705411c7b4c253e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb888a1dc7f658281705411c7b4c253e">&#9670;&nbsp;</a></span>ARAPlugInInstanceRoleFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___plug-_in___extension.html#gadb888a1dc7f658281705411c7b4c253e">ARAPlugInInstanceRoleFlags</a> : <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plug-in instance role flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadb888a1dc7f658281705411c7b4c253ea5f7f13e0744f8a3b1a0167aef4cc91ca"></a>kARAPlaybackRendererRole&#160;</td><td class="fielddoc"><p>Role: playback render. Plug-in instances fulfilling this role are performing playback rendering, both for realtime song playback or for offline or realtime bounces/exports. Playback render plug-ins can be responsible for more than one playback region at a time, although hosts may prefer to use a 1:1 relationship to simplify their implementation and easily allow for further per-region processing in the host (fades, region gain). When dealing with looped regions and using the content based fades, a trivial optimization of the above pattern is to use the same renderer instance for all consecutive repetitions of the loop, which still allows for properly applying region gain and fades at the start or end of the consecutive repetitions. Another viable approach would be to use as many playback renderer instances per track as there are concurrently sounding regions on the track (i.e. including head and tail time), and distribute the regions in a round-robin fashion across those renderers so that in each renderer the regions never overlap. This way, the host could extract a separate signal per region with a minimal count of playback renderers. Note that there may be several playback renderers per playback region, for example if a host executes an export as background tasks that run concurrently with realtime playback. A playback render plug-in will replace its inputs with the rendered signal. If it does not also have editor rendering responsibilities, it does not need to be rendered while stopped, and during playback only needs to be rendered for the range covered by the region, plus its head and tail time. Playback renderers are transient, the host does not need to store the state of these instances via the companion API (unless they also fulfill kARAEditorViewRole or other persistent roles). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadb888a1dc7f658281705411c7b4c253ea43bac0cdb9433838cab4b79734aa4486"></a>kARAEditorRendererRole&#160;</td><td class="fielddoc"><p>Role: editor render. Plug-in instances fulfilling this role are performing auxiliary realtime rendering that is only used to support the editing process, such as metronome clicks or playing the pitch of a note while it's being dragged to a different pitch. There should only be one plug-in instance that handles editor rendering for any given playback region. Since it is up to the plug-in to decide when it will generate previewing output based on the editing, it needs to be permanently rendered by the host. If a editor rendering plug-in is not responsible for playback, it will always forward its input signal to the output, adding its preview signal as needed. Otherwise it will add the signal to the playback render output described above. Editor renderers are transient, the host does not need to store the state of these instances via the companion API (unless they also fulfill kARAEditorViewRole or other persistent roles). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadb888a1dc7f658281705411c7b4c253eac033ffe4d4ae6821fe05a418929cf093"></a>kARAEditorViewRole&#160;</td><td class="fielddoc"><p>Role: editor view. Plug-in instances fulfilling this role can be used to display a GUI. Unlike rendering for playback or editing, the view role is not tied to individual playback regions or region sequences, but rather to all regions and sequences within the document controller to which the given plug-in instance is bound. Selection and hiding of host entities is communicated to editor view plug-ins so that they can dynamically show a proper subset of the full document graph. Editor view plug-ins may contain some state related to user interface configuration, and thus their state needs to be persistent via the companion API. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
