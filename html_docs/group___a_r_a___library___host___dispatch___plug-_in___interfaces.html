<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARA SDK 2.2.0: Plug-In Interfaces</title>
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="shortcut icon" sizes="16x16" href="./favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="DoxygenStyleSheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ARA_Logo.png" height="50px"/></td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___a_r_a___library___host___dispatch___plug-_in___interfaces.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Plug-In Interfaces<div class="ingroups"><a class="el" href="group___a_r_a___library.html">ARA C++ Library</a> &raquo; <a class="el" href="group___a_r_a___library___plug_in___dispatch.html">Plug-In Dispatch</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Interfaces to be implemented by ARA plug-ins. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:class_a_r_a_1_1_plug_in_1_1_document_controller_interface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_document_controller_interface">ARA::PlugIn::DocumentControllerInterface</a></td></tr>
<tr class="memdesc:class_a_r_a_1_1_plug_in_1_1_document_controller_interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for implementing <a class="el" href="group___plug-_in___document___controller.html#struct_a_r_a_document_controller_interface" title="Plug-in interface: document controller. The function pointers in this struct must remain valid until ...">ARADocumentControllerInterface</a>.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_document_controller_interface">More...</a><br /></td></tr>
<tr class="separator:class_a_r_a_1_1_plug_in_1_1_document_controller_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_a_r_a_1_1_plug_in_1_1_document_controller_instance"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_document_controller_instance">ARA::PlugIn::DocumentControllerInstance</a></td></tr>
<tr class="memdesc:class_a_r_a_1_1_plug_in_1_1_document_controller_instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for the <a class="el" href="group___plug-_in___document___controller___instance.html#struct_a_r_a_document_controller_instance" title="The document controller instance struct and all interfaces and refs therein must remain valid until t...">ARADocumentControllerInstance</a>.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_document_controller_instance">More...</a><br /></td></tr>
<tr class="separator:class_a_r_a_1_1_plug_in_1_1_document_controller_instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_a_r_a_1_1_plug_in_1_1_playback_renderer_interface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_playback_renderer_interface">ARA::PlugIn::PlaybackRendererInterface</a></td></tr>
<tr class="memdesc:class_a_r_a_1_1_plug_in_1_1_playback_renderer_interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for implementing <a class="el" href="group___playback___renderer___interface.html#struct_a_r_a_playback_renderer_interface" title="Plug-in interface: playback renderer. The function pointers in this struct must remain valid until th...">ARAPlaybackRendererInterface</a>.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_playback_renderer_interface">More...</a><br /></td></tr>
<tr class="separator:class_a_r_a_1_1_plug_in_1_1_playback_renderer_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_a_r_a_1_1_plug_in_1_1_editor_renderer_interface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_editor_renderer_interface">ARA::PlugIn::EditorRendererInterface</a></td></tr>
<tr class="memdesc:class_a_r_a_1_1_plug_in_1_1_editor_renderer_interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for implementing <a class="el" href="group___editor___renderer___interface.html#struct_a_r_a_editor_renderer_interface" title="Plug-in interface: editor renderer. The function pointers in this struct must remain valid until the ...">ARAEditorRendererInterface</a>.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_editor_renderer_interface">More...</a><br /></td></tr>
<tr class="separator:class_a_r_a_1_1_plug_in_1_1_editor_renderer_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_a_r_a_1_1_plug_in_1_1_editor_view_interface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_editor_view_interface">ARA::PlugIn::EditorViewInterface</a></td></tr>
<tr class="memdesc:class_a_r_a_1_1_plug_in_1_1_editor_view_interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for implementing <a class="el" href="group___editor___view___interface.html#struct_a_r_a_editor_view_interface" title="Plug-in interface: view controller. The function pointers in this struct must remain valid until the ...">ARAEditorViewInterface</a>.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_editor_view_interface">More...</a><br /></td></tr>
<tr class="separator:class_a_r_a_1_1_plug_in_1_1_editor_view_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_a_r_a_1_1_plug_in_1_1_plug_in_extension_instance"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_plug_in_extension_instance">ARA::PlugIn::PlugInExtensionInstance</a></td></tr>
<tr class="memdesc:class_a_r_a_1_1_plug_in_1_1_plug_in_extension_instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for <a class="el" href="group___plug-_in___extension.html#struct_a_r_a_plug_in_extension_instance" title="The plug-in extension instance struct and all interfaces and refs therein must remain valid until the...">ARAPlugInExtensionInstance</a>.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_plug_in_extension_instance">More...</a><br /></td></tr>
<tr class="separator:class_a_r_a_1_1_plug_in_1_1_plug_in_extension_instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="class_a_r_a_1_1_plug_in_1_1_document_controller_interface" id="class_a_r_a_1_1_plug_in_1_1_document_controller_interface"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_a_r_a_1_1_plug_in_1_1_document_controller_interface">&#9670;&nbsp;</a></span>ARA::PlugIn::DocumentControllerInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ARA::PlugIn::DocumentControllerInterface</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Base class for implementing <a class="el" href="group___plug-_in___document___controller.html#struct_a_r_a_document_controller_interface" title="Plug-in interface: document controller. The function pointers in this struct must remain valid until ...">ARADocumentControllerInterface</a>. </p>
</div><div class="dynheader">
Inheritance diagram for ARA::PlugIn::DocumentControllerInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___a_r_a___library___host___dispatch___plug-_in___interfaces.png" usemap="#ARA::PlugIn::DocumentControllerInterface_map" alt=""/>
  <map id="ARA::PlugIn::DocumentControllerInterface_map" name="ARA::PlugIn::DocumentControllerInterface_map">
<area href="group___a_r_a___library___a_r_a_plug___document___controller.html#class_a_r_a_1_1_plug_in_1_1_document_controller" title="Customizable default implementation of DocumentControllerInterface." alt="ARA::PlugIn::DocumentController" shape="rect" coords="0,56,247,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Destruction</h3></td></tr>
<tr class="memitem:a05ca7a307630db52948a9c15b00d678b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a05ca7a307630db52948a9c15b00d678b">destroyDocumentController</a> () noexcept=0</td></tr>
<tr class="memdesc:a05ca7a307630db52948a9c15b00d678b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the controller and its associated document. The host must delete all objects associated with the document graph (audio sources, musical contexts etc.) before making this call. Note that the objects exported via the <a class="el" href="group___plug-_in___extension.html#struct_a_r_a_plug_in_extension_instance" title="The plug-in extension instance struct and all interfaces and refs therein must remain valid until the...">ARAPlugInExtensionInstance</a> are not considered part of the document graph, their destruction may happen before or after destroying the document controller that they are bound to.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a05ca7a307630db52948a9c15b00d678b">More...</a><br /></td></tr>
<tr class="separator:a05ca7a307630db52948a9c15b00d678b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Factory</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp1c6e980e0eee73a9a9512439f56665c5"></a>Query the static ARA factory that was used to create this controller. This provides a convenient traversal to the name of the plug-in, the description of its capabilities, its archive IDs etc.</p>
</td></tr>
<tr class="memitem:a44db8325af8b302e2c0983ca1c456b17"><td class="memItemLeft" align="right" valign="top"><a id="a44db8325af8b302e2c0983ca1c456b17"></a>
virtual const <a class="el" href="group___plug-_in___factory.html#struct_a_r_a_factory">ARAFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getFactory</b> () const noexcept=0</td></tr>
<tr class="separator:a44db8325af8b302e2c0983ca1c456b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Update Management</h3></td></tr>
<tr class="memitem:a931bd74210ce6ec6abeb07fabaf4383a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a">beginEditing</a> () noexcept=0</td></tr>
<tr class="memdesc:a931bd74210ce6ec6abeb07fabaf4383a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an editing session on a document. An editing session can contain an arbitrary set of modifications that belong together. Since many model edits can result in rather expensive updates on the plug-in side, this call allows for grouping the edits and postponing the updates until the new model state is final, which potentially saves some intermediate updates.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a">More...</a><br /></td></tr>
<tr class="separator:a931bd74210ce6ec6abeb07fabaf4383a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d465eb57035ff705d9576aa7bb63a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6">endEditing</a> () noexcept=0</td></tr>
<tr class="memdesc:a40d465eb57035ff705d9576aa7bb63a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">End an editing session on a document. Note that when receiving this call, the plug-in will update any amount of internal state. These edits may lead to update notifications to the host, and the host may in turn read affected content from the plug-in and update its own model accordingly. One example for this the way that Melodyne maintains chords and scales associated with audio modifications. It copies this data from the musical context into the audio modifications, so that when editing regions the notes appear in the proper pitch grid. If moving playback regions in the song, these copies may need to be updated, and Melodyne will report the resulting audio modification content changes to the host. To ensure that any such follow-up updates are added to the same undo cycle, hosts that actively read plug-in content data should immediately (i.e. within the same undo frame) call <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#adbfe7b9261ae7834d4a315427a248867" title="Tell the plug-in to send all pending update notifications for the given document. This must be called...">notifyModelUpdates()</a> after making this call.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6">More...</a><br /></td></tr>
<tr class="separator:a40d465eb57035ff705d9576aa7bb63a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfe7b9261ae7834d4a315427a248867"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#adbfe7b9261ae7834d4a315427a248867">notifyModelUpdates</a> () noexcept=0</td></tr>
<tr class="memdesc:adbfe7b9261ae7834d4a315427a248867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the plug-in to send all pending update notifications for the given document. This must be called periodically by the host whenever not editing nor restoring the document. Only when processing this call, the plug-in may call back into the host using <a class="el" href="group___host___model___update___controller___interface.html#struct_a_r_a_model_update_controller_interface" title="Host interface: model update controller. As with all host interfaces, the function pointers in this s...">ARAModelUpdateControllerInterface</a>. Hosts must be aware after receiving <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a>, plug-ins may choose to postpone any subset of their internal state updates until the matching call to <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. This means that if the host for some reason needs to wait for a specific update in the plug-in to occur (such as waiting for an analysis to finish) it must do so outside of pairs of <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#adbfe7b9261ae7834d4a315427a248867">More...</a><br /></td></tr>
<tr class="separator:adbfe7b9261ae7834d4a315427a248867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Archiving</h3></td></tr>
<tr class="memitem:a439a668fb1f0db06d06df534b13c9054"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a439a668fb1f0db06d06df534b13c9054">restoreObjectsFromArchive</a> (<a class="el" href="group___host___archiving___controller.html#ga05025b209d04967af019d599e4cf5838">ARAArchiveReaderHostRef</a> archiveReaderHostRef, const <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_restore_objects_filter">ARARestoreObjectsFilter</a> *filter) noexcept=0</td></tr>
<tr class="memdesc:a439a668fb1f0db06d06df534b13c9054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unarchive the internal state of the specified objects. This call can be used both for unarchiving entire documents and for importing arbitrary objects into an existing document. An unarchiving session is conceptually identical to an editing session: after starting the session, the host rebuilds the graph using the regular object creation calls, then makes this call to let the plug-in parse the archive and inject the archived internal state into the graph as indicated by the persistentIDs of the relevant objects. Similarly, when importing objects, the host will perform an editing session and either create new objects or re-use existing objects (potentially adjusting their persistentID), then make this call to inject the imported state.  <br>                               The optional filter allows for restoring only a subset of the archived states into the graph. It can be NULL, in which case all archived states with matching persistentIDs will be restored. In that case, the call sequence <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a>, <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a439a668fb1f0db06d06df534b13c9054" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">restoreObjectsFromArchive()</a>, <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> is equivalent to the deprecated begin-/endRestoringDocumentFromArchive() for ARA 1, which has been superseded by this call. The host is not required to restore all objects in the archive. Any archived states that are either filtered explicitly, or for which there is no object with a matching persistent ID in the current graph are simply ignored. Since persistent IDs are only required to be unique per document (and not globally), hosts may encounter persistent ID conflicts when importing data from other documents. The optional <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_restore_objects_filter" title="Optional filter when restoring objects.  &lt;br&gt;                               \newline                 ...">ARARestoreObjectsFilter</a> provided for this call therefore allows to map between the IDs used in the archive and those used in the current graph if needed.  <br>                               The host can make multiple calls to <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a439a668fb1f0db06d06df534b13c9054" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">restoreObjectsFromArchive()</a> within the same editing session to import objects from multiple archives in one operation. It may even decide to implement its persistency based on partial archives entirely, using several calls to <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a8e0264b139236a7ea2b3959c49f594fe" title="Create a partial archive of the internal state of the specified objects. Archives may only be created...">storeObjectsToArchive()</a> with varying filters to split the document into slices appropriate to its implementation, see <a class="el" href="group___partial___document___persistency.html#a24ecfb6be6f94eed4038ea9d6ac202ea" title="Flag to indicate whether the plug-in should include its private, opaque document state in the archive...">ARAStoreObjectsFilter::documentData</a>.  <br>                               Result is kARAFalse if the access to the archive reader failed while trying to read the archive, or if decoding the data failed, kARATrue otherwise. Potential reason for failure include data corruption due to storage hardware failures, or broken dependencies when restoring partial archives as discussed above. The plug-in should try to recover as much state as possible in all cases, and the host should notify the user of such errors. If a failure happened already while reading the archive, the host is aware of this and can augment its error message to the user accordingly. If the failure happens inside the plug-in when decoding the data, the plug-in is responsible for guiding the user as good as possible, e.g. by listing or marking the affected objects. Note that since versioning is expressed through the ARA factory, the host must deal with potential versioning conflicts before making this call, and provide proper UI too.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a439a668fb1f0db06d06df534b13c9054">More...</a><br /></td></tr>
<tr class="separator:a439a668fb1f0db06d06df534b13c9054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0264b139236a7ea2b3959c49f594fe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a8e0264b139236a7ea2b3959c49f594fe">storeObjectsToArchive</a> (<a class="el" href="group___host___archiving___controller.html#gac673356af66f264ace3fb7c694e22c86">ARAArchiveWriterHostRef</a> archiveWriterHostRef, const <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_store_objects_filter">ARAStoreObjectsFilter</a> *filter) noexcept=0</td></tr>
<tr class="memdesc:a8e0264b139236a7ea2b3959c49f594fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial archive of the internal state of the specified objects. Archives may only be created from documents that are not being currently edited. The optional filter allows for storing only a subset of the document graph into the archive. It can be NULL, in which case all objects in the graph will be stored. In that case, the call is equivalent to the deprecated storeDocumentToArchive(), which has been superseded by this call. Result is kARAFalse if the access to the archive writer failed while trying to write the archive, kARATrue otherwise. The host is responsible for alerting the user about archive write errors, see <a class="el" href="group___host___archiving___controller.html#a39ccce1c9ea18b0303e5633c8b0ddefd" title="Write bytes. This may only be called from storeObjectsToArchive() or the deprecated storeDocumentToAr...">ARAArchivingControllerInterface::writeBytesToArchive()</a>. Note that for creating ARA audio file chunk archives, <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a91b6aac6ce3b6db7547058fe6a2e305f" title="Create an archive of the internal state of the specified audio source suitable to be embedded into th...">storeAudioSourceToAudioFileChunk()</a> must be used instead, so that the plug-in can pick the correct encoding and return the corresponding (compatible) document archive ID.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a8e0264b139236a7ea2b3959c49f594fe">More...</a><br /></td></tr>
<tr class="separator:a8e0264b139236a7ea2b3959c49f594fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b6aac6ce3b6db7547058fe6a2e305f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a91b6aac6ce3b6db7547058fe6a2e305f">storeAudioSourceToAudioFileChunk</a> (<a class="el" href="group___host___archiving___controller.html#gac673356af66f264ace3fb7c694e22c86">ARAArchiveWriterHostRef</a> archiveWriterHostRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___object___references.html#ga4debd59b541464cf35ccfd48ed8d6e68">ARAPersistentID</a> *documentArchiveID, bool *openAutomatically) noexcept=0</td></tr>
<tr class="memdesc:a91b6aac6ce3b6db7547058fe6a2e305f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an archive of the internal state of the specified audio source suitable to be embedded into the underlying audio file as ARA audio file chunks, see <a class="el" href="group___a_r_a_audio_file_chunks.html">ARA Audio File Chunks</a>. Hosts must check <a class="el" href="group___plug-_in___factory.html#a109051a3e886c9522ea4dd03ffc34fc3" title="Flag whether the plug-in supports exporting ARA audio file chunks via ARADocumentControllerInterface:...">ARAFactory::supportsStoringAudioFileChunks</a> before enabling users to store audio file chunks for the given plug-in. Archives may only be created from documents that are not being currently edited.  <br>                               This call differs from using <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a8e0264b139236a7ea2b3959c49f594fe" title="Create a partial archive of the internal state of the specified objects. Archives may only be created...">storeObjectsToArchive()</a> with an <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_store_objects_filter" title="Optional filter when storing objects.  &lt;br&gt;                               \newline                   ...">ARAStoreObjectsFilter</a> in that the plug-in may choose a different internal encoding more suitable for this use case, indicated by returning a <code>documentArchiveID</code> that is likely one of the <a class="el" href="group___plug-_in___factory.html#ad086f2eb62f7a90a0ea6fa22f5ea6f78" title="Variable-sized C array listing other identifiers of archives that the document controller can import....">ARAFactory::compatibleDocumentArchiveIDs</a> rather than the <a class="el" href="group___plug-_in___factory.html#adebff6774723eb0490324afdcb2a993d" title="Identifier for document archives created by the document controller. This ID must be globally unique ...">ARAFactory::documentArchiveID</a>. The plug-in also returns whether openAutomatically should be set in the audio file chunk. Result is kARAFalse if the access to the archive writer failed while trying to write the archive, kARATrue otherwise. The host is responsible for alerting the user about archive write errors, see <a class="el" href="group___host___archiving___controller.html#a39ccce1c9ea18b0303e5633c8b0ddefd" title="Write bytes. This may only be called from storeObjectsToArchive() or the deprecated storeDocumentToAr...">ARAArchivingControllerInterface::writeBytesToArchive()</a>.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a91b6aac6ce3b6db7547058fe6a2e305f">More...</a><br /></td></tr>
<tr class="separator:a91b6aac6ce3b6db7547058fe6a2e305f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Document Management</h3></td></tr>
<tr class="memitem:a9bc1bbf67a6be2937256998c3beaaf95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a9bc1bbf67a6be2937256998c3beaaf95">updateDocumentProperties</a> (<a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___document.html#struct_a_r_a_document_properties">ARADocumentProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:a9bc1bbf67a6be2937256998c3beaaf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of the controller's document. All properties must be specified, the plug-in will determine which have actually changed.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a9bc1bbf67a6be2937256998c3beaaf95">More...</a><br /></td></tr>
<tr class="separator:a9bc1bbf67a6be2937256998c3beaaf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Musical Context Management</h3></td></tr>
<tr class="memitem:afbf1dac990fca8f6284887a503452580"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#afbf1dac990fca8f6284887a503452580">createMusicalContext</a> (<a class="el" href="group___model___musical___context.html#ga43976cbd88a15e2b89d66ea2c019619b">ARAMusicalContextHostRef</a> hostRef, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___musical___context.html#struct_a_r_a_musical_context_properties">ARAMusicalContextProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:afbf1dac990fca8f6284887a503452580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new musical context associated with the controller's document.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#afbf1dac990fca8f6284887a503452580">More...</a><br /></td></tr>
<tr class="separator:afbf1dac990fca8f6284887a503452580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20016bea45d1e69dc231a58d6cb0fd7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a20016bea45d1e69dc231a58d6cb0fd7e">updateMusicalContextProperties</a> (<a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a> musicalContextRef, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___musical___context.html#struct_a_r_a_musical_context_properties">ARAMusicalContextProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:a20016bea45d1e69dc231a58d6cb0fd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of a given musical context. All properties must be specified, the plug-in will determine which have actually changed.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a20016bea45d1e69dc231a58d6cb0fd7e">More...</a><br /></td></tr>
<tr class="separator:a20016bea45d1e69dc231a58d6cb0fd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638c8f20d933518251dbb632dd91cb07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a638c8f20d933518251dbb632dd91cb07">updateMusicalContextContent</a> (<a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a> musicalContextRef, const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *range, <a class="el" href="group___a_r_a___library___utility___content___update___scopes.html#class_a_r_a_1_1_content_update_scopes">ContentUpdateScopes</a> scopeFlags) noexcept=0</td></tr>
<tr class="memdesc:a638c8f20d933518251dbb632dd91cb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the plug-in to update the information obtainable via content readers for a given musical context. The time range may be NULL, this means that the entire musical content is affected. Creating a new musical context implies an initial content update for it - the host will call this explicitly only for later content updates.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a638c8f20d933518251dbb632dd91cb07">More...</a><br /></td></tr>
<tr class="separator:a638c8f20d933518251dbb632dd91cb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ad68c4bc81d87e3ef571622481d322"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a66ad68c4bc81d87e3ef571622481d322">destroyMusicalContext</a> (<a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a> musicalContextRef) noexcept=0</td></tr>
<tr class="memdesc:a66ad68c4bc81d87e3ef571622481d322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a given musical context. Destroying a musical context also implies removing it from its document. The musical context must no longer be referred to by any playback region when making this call.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a66ad68c4bc81d87e3ef571622481d322">More...</a><br /></td></tr>
<tr class="separator:a66ad68c4bc81d87e3ef571622481d322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Region Sequence Management</h3></td></tr>
<tr class="memitem:acf846c0e444863caaea4d8dd26ef38c0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acf846c0e444863caaea4d8dd26ef38c0">createRegionSequence</a> (<a class="el" href="group___model___region___sequences.html#gae00b011383547d39b0ad55e2e908a248">ARARegionSequenceHostRef</a> hostRef, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___region___sequences.html#struct_a_r_a_region_sequence_properties">ARARegionSequenceProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:acf846c0e444863caaea4d8dd26ef38c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new region sequence associated with the controller's document.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acf846c0e444863caaea4d8dd26ef38c0">More...</a><br /></td></tr>
<tr class="separator:acf846c0e444863caaea4d8dd26ef38c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e99fc888036753212353dbafccf0e5f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a4e99fc888036753212353dbafccf0e5f">updateRegionSequenceProperties</a> (<a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a> regionSequence, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___region___sequences.html#struct_a_r_a_region_sequence_properties">ARARegionSequenceProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:a4e99fc888036753212353dbafccf0e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of a given region sequence. All properties must be specified, the plug-in will determine which have actually changed.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a4e99fc888036753212353dbafccf0e5f">More...</a><br /></td></tr>
<tr class="separator:a4e99fc888036753212353dbafccf0e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051d5d411938547e18df8ba873655ead"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a051d5d411938547e18df8ba873655ead">destroyRegionSequence</a> (<a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a> regionSequence) noexcept=0</td></tr>
<tr class="memdesc:a051d5d411938547e18df8ba873655ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a given region sequence. The region sequence must no longer be referred to by any playback region when making this call.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a051d5d411938547e18df8ba873655ead">More...</a><br /></td></tr>
<tr class="separator:a051d5d411938547e18df8ba873655ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Audio Source Management</h3></td></tr>
<tr class="memitem:ad9a2c8781f8a46a1a57cf0c3d9217fab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad9a2c8781f8a46a1a57cf0c3d9217fab">createAudioSource</a> (<a class="el" href="group___model___audio___source.html#gae2713ff3141693215d2b4da01b1ac445">ARAAudioSourceHostRef</a> hostRef, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___audio___source.html#struct_a_r_a_audio_source_properties">ARAAudioSourceProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:ad9a2c8781f8a46a1a57cf0c3d9217fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new audio source associated with the controller's document. The newly created audio source has its sample data access initially disabled, an explicit call to <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ab05b440d0590981cf47c37171b0e0af7" title="Enable or disable access to a given audio source. This call allows the host to control the time when ...">enableAudioSourceSamplesAccess()</a> is needed.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad9a2c8781f8a46a1a57cf0c3d9217fab">More...</a><br /></td></tr>
<tr class="separator:ad9a2c8781f8a46a1a57cf0c3d9217fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a21c60ee264dff98e6e43cb79d6a700"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a2a21c60ee264dff98e6e43cb79d6a700">updateAudioSourceProperties</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___audio___source.html#struct_a_r_a_audio_source_properties">ARAAudioSourceProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:a2a21c60ee264dff98e6e43cb79d6a700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of a given audio source. Depending on which properties are changed (see documentation of <a class="el" href="group___model___audio___source.html#struct_a_r_a_audio_source_properties" title="Audio source properties. Note that like all properties, a pointer to this struct is only valid for th...">ARAAudioSourceProperties</a>), the host may not be able to make this call while the plug-in is reading data - in that case, use <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ab05b440d0590981cf47c37171b0e0af7" title="Enable or disable access to a given audio source. This call allows the host to control the time when ...">enableAudioSourceSamplesAccess()</a> accordingly. All properties must be specified, the plug-in will determine which have actually changed.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a2a21c60ee264dff98e6e43cb79d6a700">More...</a><br /></td></tr>
<tr class="separator:a2a21c60ee264dff98e6e43cb79d6a700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f90d2a38540e8b732b4120c5c28a4aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a0f90d2a38540e8b732b4120c5c28a4aa">updateAudioSourceContent</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *range, <a class="el" href="group___a_r_a___library___utility___content___update___scopes.html#class_a_r_a_1_1_content_update_scopes">ContentUpdateScopes</a> scopeFlags) noexcept=0</td></tr>
<tr class="memdesc:a0f90d2a38540e8b732b4120c5c28a4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the plug-in that the sample data or content information for the given audio source has changed. Not to be called in response to <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a>. The time range may be NULL, this means that the entire audio source is affected. When implementing this call, remember to also flush any caches of the sampled data if needed (see <a class="el" href="group___model___content___updates.html#gga74195b82b008866a82ca9dc2d226485ca34fb9ac9367757d532012c08185eac8b" title="The actual signal is unaffected by the change. Note that in some cases even when the signal is consid...">kARAContentUpdateSignalScopeRemainsUnchanged</a>). Creating a new audio source always implies an initial content update for it, i.e. the host will call this function only for later content updates. Since audio sources are persistent, plug-ins should preferably postpone the initial content reading until <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> - if the host is restoring the audio source, this will remove the need to read initial content.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a0f90d2a38540e8b732b4120c5c28a4aa">More...</a><br /></td></tr>
<tr class="separator:a0f90d2a38540e8b732b4120c5c28a4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05b440d0590981cf47c37171b0e0af7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ab05b440d0590981cf47c37171b0e0af7">enableAudioSourceSamplesAccess</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, bool enable) noexcept=0</td></tr>
<tr class="memdesc:ab05b440d0590981cf47c37171b0e0af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable access to a given audio source. This call allows the host to control the time when the plug-in may access sample data from the given audio source. Disabling access forces the plug-in to destroy all audio readers it currently has created for the affected audio source. This is a synchronous call, blocking until all currently executing reads of the audio source are finished. Access is disabled by default, hosts must explicitly enable it after creating an audio source. Since this call does not modify the model graph, it may be called outside the usual <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> scope. Note that disabling access will also abort any analysis currently being executed for the audio source, making it necessary to start it from scratch when the access is enabled again. This means that <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ab05b440d0590981cf47c37171b0e0af7" title="Enable or disable access to a given audio source. This call allows the host to control the time when ...">enableAudioSourceSamplesAccess()</a> is an expensive call that only should be made when necessary. It should not be (ab-)used to simply "pause ARA" whenever convenient.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ab05b440d0590981cf47c37171b0e0af7">More...</a><br /></td></tr>
<tr class="separator:ab05b440d0590981cf47c37171b0e0af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe1e7f19bbfabc5c07e65f7011c166c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#aefe1e7f19bbfabc5c07e65f7011c166c">deactivateAudioSourceForUndoHistory</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, bool deactivate) noexcept=0</td></tr>
<tr class="memdesc:aefe1e7f19bbfabc5c07e65f7011c166c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate the given audio source because it has become part of the undo history and is no longer used actively. The plug-in will cancel any pending analysis for this audio source and may free memory that is only needed when the audio source can be edited or rendered. Before deactivating an audio source, the host must deactivate all associated audio modifications, and the opposite order is required when re-activating upon redo. When deactivated, updating the properties or content of the audio source or reading its content is no longer valid. Like properties, deactivation is not necessarily persistent in the plug-in, so the host must call this explicitly when restoring deactivated audio sources. Note that with the introduction of partial persistency with ARA 2.0, hosts likely will prefer to simply create partial archives of deleted audio sources and manage these in their undo history rather than utilizing this call.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#aefe1e7f19bbfabc5c07e65f7011c166c">More...</a><br /></td></tr>
<tr class="separator:aefe1e7f19bbfabc5c07e65f7011c166c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4acb7d30b6ebdb7be57e32a1442e5d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ac4acb7d30b6ebdb7be57e32a1442e5d8">destroyAudioSource</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef) noexcept=0</td></tr>
<tr class="memdesc:ac4acb7d30b6ebdb7be57e32a1442e5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a given audio source. Destroying an audio source also implies removing it from its document. The host must delete all objects associated with the audio source (audio modifications etc.) before deleting the audio source. The host does not need to explicitly disable access to the audio source before making this call.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ac4acb7d30b6ebdb7be57e32a1442e5d8">More...</a><br /></td></tr>
<tr class="separator:ac4acb7d30b6ebdb7be57e32a1442e5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Audio Modification Management</h3></td></tr>
<tr class="memitem:acdc22d37fc6a122bd08f90b3a11e6281"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acdc22d37fc6a122bd08f90b3a11e6281">createAudioModification</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___model___audio___modification.html#ga4fcadfe860312728c065593e1f7cf104">ARAAudioModificationHostRef</a> hostRef, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___audio___modification.html#struct_a_r_a_audio_modification_properties">ARAAudioModificationProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:acdc22d37fc6a122bd08f90b3a11e6281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new audio modification associated with the given audio source.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acdc22d37fc6a122bd08f90b3a11e6281">More...</a><br /></td></tr>
<tr class="separator:acdc22d37fc6a122bd08f90b3a11e6281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cee9624949fc2e43b3013a1cf8b5974"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a8cee9624949fc2e43b3013a1cf8b5974">cloneAudioModification</a> (<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___model___audio___modification.html#ga4fcadfe860312728c065593e1f7cf104">ARAAudioModificationHostRef</a> hostRef, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___audio___modification.html#struct_a_r_a_audio_modification_properties">ARAAudioModificationProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:a8cee9624949fc2e43b3013a1cf8b5974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new audio modification that copies the state of another given audio modification. The new modification will be associated with the same audio source. This call is used to create independent variations of the audio as opposed to creating aliases by merely adding playback regions to a given audio modification.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a8cee9624949fc2e43b3013a1cf8b5974">More...</a><br /></td></tr>
<tr class="separator:a8cee9624949fc2e43b3013a1cf8b5974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92710846f657ab433d3b284d4395c08f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a92710846f657ab433d3b284d4395c08f">updateAudioModificationProperties</a> (<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___audio___modification.html#struct_a_r_a_audio_modification_properties">ARAAudioModificationProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:a92710846f657ab433d3b284d4395c08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of a given audio modification. All properties must be specified, the plug-in will determine which have actually changed.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a92710846f657ab433d3b284d4395c08f">More...</a><br /></td></tr>
<tr class="separator:a92710846f657ab433d3b284d4395c08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c2222fa0743555fc3c2258ec8a0a51"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad5c2222fa0743555fc3c2258ec8a0a51">isAudioModificationPreservingAudioSourceSignal</a> (<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef) noexcept=0</td></tr>
<tr class="memdesc:ad5c2222fa0743555fc3c2258ec8a0a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some hosts such as Pro Tools provide indicators whether a given plug-in's current settings cause it to alter the sound of the original audio source, or preserve it so that bypassing/removing the plug-in would not change the perceived audible result (note that actual rendering involves using a playback region, which still may apply time-stretching or pitch-shifting to the audio modification's potentially unaltered output).  <br>                               Changes to this state are tracked via <a class="el" href="group___host___model___update___controller___interface.html#af8ff42d436d6a83fe7605f06e49e6b52" title="Message to the host when content of the given audio modification changes. Not to be called if the cha...">ARAModelUpdateControllerInterface::notifyAudioModificationContentChanged()</a> with <a class="el" href="group___model___content___updates.html#gga74195b82b008866a82ca9dc2d226485ca34fb9ac9367757d532012c08185eac8b" title="The actual signal is unaffected by the change. Note that in some cases even when the signal is consid...">kARAContentUpdateSignalScopeRemainsUnchanged</a> == false. Note that it is possible to perform other edits such as reassigning the chords associated with the audio modification which would not affect this state.  <br>                               It is valid for plug-in implementations to deliver false negatives here to reasonably limit the cost of maintaining the state. For example, if the plug-in does some threshold-based processing, but the signal happens to never actually reach the threshold, the plug-in still may report to alter the sound. Another example is pitch&amp;time editing in a Melodyne-like plug-in: if notes are moved to a different pitch or time position so that this flag is cleared, but later the user manually moves them back to the original location, this might not cause this flag to turn back on. If however the user invokes undo, or some explicit reset command instead of the manual adjustment, then the plug-in should maintain this state properly.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad5c2222fa0743555fc3c2258ec8a0a51">More...</a><br /></td></tr>
<tr class="separator:ad5c2222fa0743555fc3c2258ec8a0a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a04ee4787a1a8607062993121494a06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a0a04ee4787a1a8607062993121494a06">deactivateAudioModificationForUndoHistory</a> (<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, bool deactivate) noexcept=0</td></tr>
<tr class="memdesc:a0a04ee4787a1a8607062993121494a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate the given audio modification because it has become part of the undo history and is no longer used actively. The plug-in may free some memory that is only needed when the audio modification can be edited or rendered. Before deactivating an audio modification, the host must destroy all associated playback regions, and the opposite order is required when re-activating upon redo. When deactivated, updating the properties of the audio modification or reading its content is no longer valid. Like properties, deactivation is not necessarily persistent in the plug-in, so the host must call this explicitly when restoring deactivated audio modifications. Note that with the introduction of partial persistency with ARA 2.0, hosts likely will prefer to simply create partial archives of deleted audio modifications and manage these in their undo history rather than utilizing this call.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a0a04ee4787a1a8607062993121494a06">More...</a><br /></td></tr>
<tr class="separator:a0a04ee4787a1a8607062993121494a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada10dd7c658e9f9e7d75ea7cbeb21c55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ada10dd7c658e9f9e7d75ea7cbeb21c55">destroyAudioModification</a> (<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef) noexcept=0</td></tr>
<tr class="memdesc:ada10dd7c658e9f9e7d75ea7cbeb21c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a given audio modification. Destroying an audio modification also implies removing it from its audio source. The host must delete all objects associated with the audio modification (playback regions etc.) before deleting the audio modification.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ada10dd7c658e9f9e7d75ea7cbeb21c55">More...</a><br /></td></tr>
<tr class="separator:ada10dd7c658e9f9e7d75ea7cbeb21c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Playback Region Management</h3></td></tr>
<tr class="memitem:aa31a4ce868b0eed7673a2148fd47cc9a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#aa31a4ce868b0eed7673a2148fd47cc9a">createPlaybackRegion</a> (<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___model___playback___region.html#ga69daf0d4cf4ca3cf9acf2874ca1dc682">ARAPlaybackRegionHostRef</a> hostRef, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___playback___region.html#struct_a_r_a_playback_region_properties">ARAPlaybackRegionProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:aa31a4ce868b0eed7673a2148fd47cc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new playback region associated with the given audio modification.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#aa31a4ce868b0eed7673a2148fd47cc9a">More...</a><br /></td></tr>
<tr class="separator:aa31a4ce868b0eed7673a2148fd47cc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6a1c2291a89e0ceb8f3ae337ee2226"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a4e6a1c2291a89e0ceb8f3ae337ee2226">updatePlaybackRegionProperties</a> (<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef, <a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___playback___region.html#struct_a_r_a_playback_region_properties">ARAPlaybackRegionProperties</a> &gt; properties) noexcept=0</td></tr>
<tr class="memdesc:a4e6a1c2291a89e0ceb8f3ae337ee2226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of a given playback region. All properties must be specified, the plug-in will determine which have actually changed.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a4e6a1c2291a89e0ceb8f3ae337ee2226">More...</a><br /></td></tr>
<tr class="separator:a4e6a1c2291a89e0ceb8f3ae337ee2226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac417aebba9b55025c124ab95df280229"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ac417aebba9b55025c124ab95df280229">destroyPlaybackRegion</a> (<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef) noexcept=0</td></tr>
<tr class="memdesc:ac417aebba9b55025c124ab95df280229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a given playback region. Destroying a playback region also implies removing it from its audio modification. The playback region must no longer be referred to by any plug-in extension when making this call.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ac417aebba9b55025c124ab95df280229">More...</a><br /></td></tr>
<tr class="separator:ac417aebba9b55025c124ab95df280229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9024878882385a7196b27d906045359c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a9024878882385a7196b27d906045359c">getPlaybackRegionHeadAndTailTime</a> (<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef, <a class="el" href="group___common__time-related__data__types.html#gaae0f11efaa1db78be29766f7bb5627f1">ARATimeDuration</a> *headTime, <a class="el" href="group___common__time-related__data__types.html#gaae0f11efaa1db78be29766f7bb5627f1">ARATimeDuration</a> *tailTime) noexcept=0</td></tr>
<tr class="memdesc:a9024878882385a7196b27d906045359c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current head and tail time of a given playback region. Note that when a plug-in optimizes region transitions, the head and tail of any given region can change upon any model edit, even if it is not directly affected by the edit. Also, in order to properly track interaction between regions, plug-ins may lazily update this information upon <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. Plug-ins will call notifyPlaybackRegionContentChanged() whenever these values change. headTime and tailTime must not be NULL. Host may query this often, so plug-ins should cache the value if there's any expensive calculation involved. Note that most companion APIs also feature a tail time concept. For playback renderer plug-in instances, the tail time reported via the companion API should be equal to or greater than the maximum of the tail times of all playback regions currently associated with the given renderer (i.e. the tail for any given playback region may be somewhat shorter then the companion API tail, depending on the region's content).  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a9024878882385a7196b27d906045359c">More...</a><br /></td></tr>
<tr class="separator:a9024878882385a7196b27d906045359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Content Reader Management</h3></td></tr>
<tr class="memitem:a3f6b668d86c92e6e3e2a2025d5e61782"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a3f6b668d86c92e6e3e2a2025d5e61782">isAudioSourceContentAvailable</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> type) noexcept=0</td></tr>
<tr class="memdesc:a3f6b668d86c92e6e3e2a2025d5e61782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the given content type is currently available for the given audio source.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a3f6b668d86c92e6e3e2a2025d5e61782">More...</a><br /></td></tr>
<tr class="separator:a3f6b668d86c92e6e3e2a2025d5e61782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920d4417abbc218175253107f549a37f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___content___readers__and___content___events.html#ga91aa126b597a1b08dfcd01b2778ab734">ARAContentGrade</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a920d4417abbc218175253107f549a37f">getAudioSourceContentGrade</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> type) noexcept=0</td></tr>
<tr class="memdesc:a920d4417abbc218175253107f549a37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current quality of the information provided for the given audio source and content type.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a920d4417abbc218175253107f549a37f">More...</a><br /></td></tr>
<tr class="separator:a920d4417abbc218175253107f549a37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c657674b5851eb2434069ed31d917f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7c657674b5851eb2434069ed31d917f3">createAudioSourceContentReader</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> type, const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *range) noexcept=0</td></tr>
<tr class="memdesc:a7c657674b5851eb2434069ed31d917f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a content reader for the given audio source and content type. This should only be called after availability has been confirmed using <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a3f6b668d86c92e6e3e2a2025d5e61782" title="Query whether the given content type is currently available for the given audio source.">isAudioSourceContentAvailable()</a>. The time range may be NULL, which means that the entire audio source shall be read. If a time range is specified, all events that at least partially intersect with the range will be read.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7c657674b5851eb2434069ed31d917f3">More...</a><br /></td></tr>
<tr class="separator:a7c657674b5851eb2434069ed31d917f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29380f8543b7017d8e86c78c66fd9659"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a29380f8543b7017d8e86c78c66fd9659">isAudioModificationContentAvailable</a> (<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> type) noexcept=0</td></tr>
<tr class="memdesc:a29380f8543b7017d8e86c78c66fd9659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the given content type is currently available for the given audio modification. Note that since ARA 2.0, reading at playback region level is recommended for most content types, see <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acbe985f9a890a092acd5bf25b2f02620" title="Create a content reader for the given audio modification and content type. This should only be called...">createAudioModificationContentReader()</a>.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a29380f8543b7017d8e86c78c66fd9659">More...</a><br /></td></tr>
<tr class="separator:a29380f8543b7017d8e86c78c66fd9659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7970f534bad94cf77c4de7ed74aad07e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___content___readers__and___content___events.html#ga91aa126b597a1b08dfcd01b2778ab734">ARAContentGrade</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7970f534bad94cf77c4de7ed74aad07e">getAudioModificationContentGrade</a> (<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> type) noexcept=0</td></tr>
<tr class="memdesc:a7970f534bad94cf77c4de7ed74aad07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current quality of the information provided for a given audio modification and content type. Note that since ARA 2.0, reading at playback region level is recommended for most content types, see <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acbe985f9a890a092acd5bf25b2f02620" title="Create a content reader for the given audio modification and content type. This should only be called...">createAudioModificationContentReader()</a>.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7970f534bad94cf77c4de7ed74aad07e">More...</a><br /></td></tr>
<tr class="separator:a7970f534bad94cf77c4de7ed74aad07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe985f9a890a092acd5bf25b2f02620"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acbe985f9a890a092acd5bf25b2f02620">createAudioModificationContentReader</a> (<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> type, const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *range) noexcept=0</td></tr>
<tr class="memdesc:acbe985f9a890a092acd5bf25b2f02620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a content reader for the given audio modification and content type. This should only be called after availability has been confirmed using <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a29380f8543b7017d8e86c78c66fd9659" title="Query whether the given content type is currently available for the given audio modification....">isAudioModificationContentAvailable()</a>. The time range may be NULL, which means that the entire audio modification shall be read. If a time range is specified, all events that at least partially intersect with the range will be read. Note that with the introduction of region transitions in ARA 2.0, the content of a given playback region can no longer be externally calculated by the host based on the content of its underlying audio modification and the transformation flags. Instead, hosts should read such content directly at region level. This particularly applies to kARAContentTypeNotes - notes at borders will be adjusted on a per-region basis when using content based fades. Playback region content reading is available in ARA 1.0 already, thus such an implementation will be fully backwards compatible. Reading content at audio modification (or audio source) level is still valid and useful if the host needs access to the content in its original state, not transformed by a playback region, e.g. when implementing features such as tempo and signature detection through ARA.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acbe985f9a890a092acd5bf25b2f02620">More...</a><br /></td></tr>
<tr class="separator:acbe985f9a890a092acd5bf25b2f02620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89060490e5c0855c90e8257557ab12f5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a89060490e5c0855c90e8257557ab12f5">isPlaybackRegionContentAvailable</a> (<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> type) noexcept=0</td></tr>
<tr class="memdesc:a89060490e5c0855c90e8257557ab12f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the given content type is currently available for the given playback region.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a89060490e5c0855c90e8257557ab12f5">More...</a><br /></td></tr>
<tr class="separator:a89060490e5c0855c90e8257557ab12f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e665f2e7434c5a6e2250519050e643f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___content___readers__and___content___events.html#ga91aa126b597a1b08dfcd01b2778ab734">ARAContentGrade</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7e665f2e7434c5a6e2250519050e643f">getPlaybackRegionContentGrade</a> (<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> type) noexcept=0</td></tr>
<tr class="memdesc:a7e665f2e7434c5a6e2250519050e643f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current quality of the information provided for the given playback region and content type.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7e665f2e7434c5a6e2250519050e643f">More...</a><br /></td></tr>
<tr class="separator:a7e665f2e7434c5a6e2250519050e643f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989865481ef057fa37c2ddb31460ebd0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a989865481ef057fa37c2ddb31460ebd0">createPlaybackRegionContentReader</a> (<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> type, const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *range) noexcept=0</td></tr>
<tr class="memdesc:a989865481ef057fa37c2ddb31460ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a content reader for the given playback region and content type. This should only be called after availability has been confirmed using <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a89060490e5c0855c90e8257557ab12f5" title="Query whether the given content type is currently available for the given playback region.">isPlaybackRegionContentAvailable()</a>. The time range may be NULL, which means that the entire playback region shall be read, including its potential head and tail time. If a time range is specified, all events that at least partially intersect with the range will be read. The time range must be given in playback time, and the time stamps provided by the content reader are in playback time as well.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a989865481ef057fa37c2ddb31460ebd0">More...</a><br /></td></tr>
<tr class="separator:a989865481ef057fa37c2ddb31460ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf328d061fde206ee89a3fc5ba6b12b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acaf328d061fde206ee89a3fc5ba6b12b">getContentReaderEventCount</a> (<a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a> contentReaderRef) noexcept=0</td></tr>
<tr class="memdesc:acaf328d061fde206ee89a3fc5ba6b12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query how many events the given reader exposes.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acaf328d061fde206ee89a3fc5ba6b12b">More...</a><br /></td></tr>
<tr class="separator:acaf328d061fde206ee89a3fc5ba6b12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05ff58332cddc0f6d0f86c82367376b"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#af05ff58332cddc0f6d0f86c82367376b">getContentReaderDataForEvent</a> (<a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a> contentReaderRef, <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a> eventIndex) noexcept=0</td></tr>
<tr class="memdesc:af05ff58332cddc0f6d0f86c82367376b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query data of the given event of the given reader. The returned pointer is owned by the plug-in and must remain valid until either <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#af05ff58332cddc0f6d0f86c82367376b" title="Query data of the given event of the given reader. The returned pointer is owned by the plug-in and m...">getContentReaderDataForEvent()</a> is called again or the content reader is destroyed.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#af05ff58332cddc0f6d0f86c82367376b">More...</a><br /></td></tr>
<tr class="separator:af05ff58332cddc0f6d0f86c82367376b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c7d43a402ffaa74dd0c5bd60bce5b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a26c7d43a402ffaa74dd0c5bd60bce5b6">destroyContentReader</a> (<a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a> contentReaderRef) noexcept=0</td></tr>
<tr class="memdesc:a26c7d43a402ffaa74dd0c5bd60bce5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the given content reader.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a26c7d43a402ffaa74dd0c5bd60bce5b6">More...</a><br /></td></tr>
<tr class="separator:a26c7d43a402ffaa74dd0c5bd60bce5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Controlling Analysis</h3></td></tr>
<tr class="memitem:a39a8065750baed88c555dfeea75c49b8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a39a8065750baed88c555dfeea75c49b8">isAudioSourceContentAnalysisIncomplete</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType) noexcept=0</td></tr>
<tr class="memdesc:a39a8065750baed88c555dfeea75c49b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether an analysis of the given content type has been done for the given audio source. This call will typically be used when the host uses the plug-in as a detection engine in the background (i.e. without presenting the UI to the user). In that scenario, the host will trigger the analysis of the desired content types using <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7227828433c385f53d108c5021c1d310" title="Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine,...">requestAudioSourceContentAnalysis()</a> and then wait until the plug-in calls <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a>. From that call, the host will query the plug-in via <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a39a8065750baed88c555dfeea75c49b8" title="Query whether an analysis of the given content type has been done for the given audio source....">isAudioSourceContentAnalysisIncomplete()</a> to determine which of the analysis requests have completed. If the host did request a specific algorithm to be used, then the plug-in should return kARATrue here until the request was satisfied (or rejected).  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a39a8065750baed88c555dfeea75c49b8">More...</a><br /></td></tr>
<tr class="separator:a39a8065750baed88c555dfeea75c49b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7227828433c385f53d108c5021c1d310"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7227828433c385f53d108c5021c1d310">requestAudioSourceContentAnalysis</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a> contentTypesCount, const <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentTypes[]) noexcept=0</td></tr>
<tr class="memdesc:a7227828433c385f53d108c5021c1d310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine, it needs to explicitly trigger the desired analysis, since otherwise the plug-in may postpone any analysis as suitable. To allow for optimizing the analysis on the plug-in side, all content types that are of interest for the host should be specified in a single call if possible.  <br>                               Note that the plug-in may choose to perform any additional analysis at any point in time if this is appropriate for its design. It will call <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a> if such an analysis concludes successfully so that the host can update accordingly.  <br>                               The provided content types must be a non-empty subset of the plug-in's <a class="el" href="group___plug-_in___factory.html#abdefa00d5ef9074c3563d58265361525" title="Variable-sized C array listing the content types for which the plug-in can perform an analysis....">ARAFactory::analyzeableContentTypes</a>. To request all analysis types exported by the plug-in, hosts can directly pass analyzeableContentTypes and -Count from the plug-in's <a class="el" href="group___plug-_in___factory.html#struct_a_r_a_factory" title="Static plug-in factory. All pointers herein must remain valid as long as the binary is loaded....">ARAFactory</a>. The contentTypes pointer may be only valid for the duration of the call, it must be evaluated inside the call, and the pointer must not be stored anywhere.  <br>                               Note that ARA 2.0 adds the capability for the host to also request the use of a certain processing algorithm via <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a838c453c28cf96694e3002aedfec924b" title="Request that any future analysis of the given audio source should use the given processing algorithm....">requestProcessingAlgorithmForAudioSource()</a> - if both are used then the algorithm must be selected before requesting the analysis.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7227828433c385f53d108c5021c1d310">More...</a><br /></td></tr>
<tr class="separator:a7227828433c385f53d108c5021c1d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24ed42f1feab6d7f44cba062a4881eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad24ed42f1feab6d7f44cba062a4881eb">getProcessingAlgorithmsCount</a> () noexcept=0</td></tr>
<tr class="memdesc:ad24ed42f1feab6d7f44cba062a4881eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the count of processing algorithms provided by the plug-in. If this optional method is not implemented or the call returns 0, then the plug-in does not support algorithm selection through the host and the other related functions below must not be called.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad24ed42f1feab6d7f44cba062a4881eb">More...</a><br /></td></tr>
<tr class="separator:ad24ed42f1feab6d7f44cba062a4881eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b3ae6c5b508ff1f84cee58b2a7d661"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group___processing___algorithm___selection.html#struct_a_r_a_processing_algorithm_properties">ARAProcessingAlgorithmProperties</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad9b3ae6c5b508ff1f84cee58b2a7d661">getProcessingAlgorithmProperties</a> (<a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a> algorithmIndex) noexcept=0</td></tr>
<tr class="memdesc:ad9b3ae6c5b508ff1f84cee58b2a7d661"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of processing algorithms provided by the plug-in, described by their properties. This method must be implemented if <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad24ed42f1feab6d7f44cba062a4881eb" title="Return the count of processing algorithms provided by the plug-in. If this optional method is not imp...">getProcessingAlgorithmsCount()</a> is implemented. Provides a unique identifier and a user-readable name of the algorithm as displayed in the plug-in. The host should present the algorithms to the user in the order of this list, e.g. in a menu. For a given version of the plug-in, the count and the order and values of the persistentIDs must be the same, while the names may depend on localization settings that can be different on different machines or between individual runs of the host. The list may however change between different versions of the plug-in. Both hosts and plug-ins must implement fallbacks for loading a document that contains an processing algorithm persistentID which is no longer supported by the plug-in. The pointers returned by this calls must remain valid until the document controller is destroyed.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad9b3ae6c5b508ff1f84cee58b2a7d661">More...</a><br /></td></tr>
<tr class="separator:ad9b3ae6c5b508ff1f84cee58b2a7d661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41f25add1e6db62f694f1ae39eca55e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad41f25add1e6db62f694f1ae39eca55e">getProcessingAlgorithmForAudioSource</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef) noexcept=0</td></tr>
<tr class="memdesc:ad41f25add1e6db62f694f1ae39eca55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query currently used processing algorithm for a given audio source. This method must be implemented if <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad24ed42f1feab6d7f44cba062a4881eb" title="Return the count of processing algorithms provided by the plug-in. If this optional method is not imp...">getProcessingAlgorithmsCount()</a> is implemented. After the plug-in has concluded an analysis (as indicated via <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a>), the host can query which processing algorithm was used and update its UI accordingly. This is particularly relevant if the host did explicitly request an analysis with a specific algorithm, but the plug-in was unable to satisfy this request for some reason. Similarly, the user may have changed the algorithm through the plug-in's UI. Note that until the first analysis has completed (i.e. as long as <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a39a8065750baed88c555dfeea75c49b8" title="Query whether an analysis of the given content type has been done for the given audio source....">isAudioSourceContentAnalysisIncomplete()</a> returns kARATrue), the value returned here may be an abstract default, not related to the actual audio source content. This will e.g. typically be the case in Melodyne, which uses an "automatic mode" as default until the first analysis has determined the actual processing algorithm that is suitable for the material. The call should not be made while <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a39a8065750baed88c555dfeea75c49b8" title="Query whether an analysis of the given content type has been done for the given audio source....">isAudioSourceContentAnalysisIncomplete()</a> returns kARATrue, because the returned value is likely stale.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad41f25add1e6db62f694f1ae39eca55e">More...</a><br /></td></tr>
<tr class="separator:ad41f25add1e6db62f694f1ae39eca55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838c453c28cf96694e3002aedfec924b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a838c453c28cf96694e3002aedfec924b">requestProcessingAlgorithmForAudioSource</a> (<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a> algorithmIndex) noexcept=0</td></tr>
<tr class="memdesc:a838c453c28cf96694e3002aedfec924b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that any future analysis of the given audio source should use the given processing algorithm. This method must be implemented if <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad24ed42f1feab6d7f44cba062a4881eb" title="Return the count of processing algorithms provided by the plug-in. If this optional method is not imp...">getProcessingAlgorithmsCount()</a> is implemented. This both affects any analysis requested by the host via <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7227828433c385f53d108c5021c1d310" title="Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine,...">requestAudioSourceContentAnalysis()</a> as well as any analysis done by the plug-in on demand. Since this typically results in a model graph edit, calling this functions must be guarded by <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. Note that the plug-in is not required to heed this request if its internal state suggest otherwise, or if the user switches actively to a different algorithm. Also, some algorithms may be "meta" algorithms that will be replaced by a different actual algorithm, such as the "automatic" default algorithm in Melodyne which will pick an appropriate algorithm from the remaining list of algorithms when doing the initial analysis.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a838c453c28cf96694e3002aedfec924b">More...</a><br /></td></tr>
<tr class="separator:a838c453c28cf96694e3002aedfec924b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>License Management</h3></td></tr>
<tr class="memitem:a4f64c3f76f2081c0354f8e3d791cd3ad"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a4f64c3f76f2081c0354f8e3d791cd3ad">isLicensedForCapabilities</a> (bool runModalActivationDialogIfNeeded, <a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a> contentTypesCount, const <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentTypes[], <a class="el" href="group___model___playback___region.html#ga258336ff5f674225e3ec403493461179">ARAPlaybackTransformationFlags</a> transformationFlags) noexcept=0</td></tr>
<tr class="memdesc:a4f64c3f76f2081c0354f8e3d791cd3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">With this optional call, hosts can test whether the current license state of the plug-in allows for requesting analysis of the given content types and rendering the given playback transformations (see <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7227828433c385f53d108c5021c1d310" title="Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine,...">requestAudioSourceContentAnalysis()</a> and <a class="el" href="group___model___playback___region.html#a3886d84f7b2a1915afd61ffdca08d8a7" title="Configuration of possible transformations upon playback, i.e. time-stretching etc....">ARAPlaybackRegionProperties::transformationFlags</a>). The host can also optionally instruct the plug-in to run a modal licensing dialog if the current license is not sufficient to perform the selected engine tasks, so that the user can review and adjust the licensing accordingly, such downloading a license from their respective user account or even purchase an upgrade that enables the requested features.  <br>                               The provided content types must be a subset of the plug-in's <a class="el" href="group___plug-_in___factory.html#abdefa00d5ef9074c3563d58265361525" title="Variable-sized C array listing the content types for which the plug-in can perform an analysis....">ARAFactory::analyzeableContentTypes</a>. To request all analysis types exported by the plug-in, hosts can directly pass analyzeableContentTypes and -Count from the <a class="el" href="group___plug-_in___factory.html#struct_a_r_a_factory" title="Static plug-in factory. All pointers herein must remain valid as long as the binary is loaded....">ARAFactory</a>. The contentTypes pointer may be only valid for the duration of the call, it must be evaluated inside the call, and the pointer must not be stored anywhere. If not intending to use analysis, the count should be 0 and the array pointer NULL. The transformationFlags must be a subset of the plug-in's <a class="el" href="group___plug-_in___factory.html#ad86be852472fa25593b8801c4ade263a" title="Set of transformations that the plug-in supports when configuring playback regions....">ARAFactory::supportedPlaybackTransformationFlags</a>, and may be kARAPlaybackTransformationNoChanges if not intending to use transformations. The call returns kARATrue if the (potentially updated) license is sufficient to perform the requested tasks.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a4f64c3f76f2081c0354f8e3d791cd3ad">More...</a><br /></td></tr>
<tr class="separator:a4f64c3f76f2081c0354f8e3d791cd3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a931bd74210ce6ec6abeb07fabaf4383a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931bd74210ce6ec6abeb07fabaf4383a">&#9670;&nbsp;</a></span>beginEditing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::beginEditing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start an editing session on a document. An editing session can contain an arbitrary set of modifications that belong together. Since many model edits can result in rather expensive updates on the plug-in side, this call allows for grouping the edits and postponing the updates until the new model state is final, which potentially saves some intermediate updates. </p>

</div>
</div>
<a id="a8cee9624949fc2e43b3013a1cf8b5974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cee9624949fc2e43b3013a1cf8b5974">&#9670;&nbsp;</a></span>cloneAudioModification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> ARA::PlugIn::DocumentControllerInterface::cloneAudioModification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td>
          <td class="paramname"><em>audioModificationRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#ga4fcadfe860312728c065593e1f7cf104">ARAAudioModificationHostRef</a>&#160;</td>
          <td class="paramname"><em>hostRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___audio___modification.html#struct_a_r_a_audio_modification_properties">ARAAudioModificationProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new audio modification that copies the state of another given audio modification. The new modification will be associated with the same audio source. This call is used to create independent variations of the audio as opposed to creating aliases by merely adding playback regions to a given audio modification. </p>

</div>
</div>
<a id="acdc22d37fc6a122bd08f90b3a11e6281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc22d37fc6a122bd08f90b3a11e6281">&#9670;&nbsp;</a></span>createAudioModification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> ARA::PlugIn::DocumentControllerInterface::createAudioModification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#ga4fcadfe860312728c065593e1f7cf104">ARAAudioModificationHostRef</a>&#160;</td>
          <td class="paramname"><em>hostRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___audio___modification.html#struct_a_r_a_audio_modification_properties">ARAAudioModificationProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new audio modification associated with the given audio source. </p>

</div>
</div>
<a id="acbe985f9a890a092acd5bf25b2f02620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe985f9a890a092acd5bf25b2f02620">&#9670;&nbsp;</a></span>createAudioModificationContentReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a> ARA::PlugIn::DocumentControllerInterface::createAudioModificationContentReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td>
          <td class="paramname"><em>audioModificationRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a content reader for the given audio modification and content type. This should only be called after availability has been confirmed using <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a29380f8543b7017d8e86c78c66fd9659" title="Query whether the given content type is currently available for the given audio modification....">isAudioModificationContentAvailable()</a>. The time range may be NULL, which means that the entire audio modification shall be read. If a time range is specified, all events that at least partially intersect with the range will be read. Note that with the introduction of region transitions in ARA 2.0, the content of a given playback region can no longer be externally calculated by the host based on the content of its underlying audio modification and the transformation flags. Instead, hosts should read such content directly at region level. This particularly applies to kARAContentTypeNotes - notes at borders will be adjusted on a per-region basis when using content based fades. Playback region content reading is available in ARA 1.0 already, thus such an implementation will be fully backwards compatible. Reading content at audio modification (or audio source) level is still valid and useful if the host needs access to the content in its original state, not transformed by a playback region, e.g. when implementing features such as tempo and signature detection through ARA. </p>

</div>
</div>
<a id="ad9a2c8781f8a46a1a57cf0c3d9217fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a2c8781f8a46a1a57cf0c3d9217fab">&#9670;&nbsp;</a></span>createAudioSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> ARA::PlugIn::DocumentControllerInterface::createAudioSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#gae2713ff3141693215d2b4da01b1ac445">ARAAudioSourceHostRef</a>&#160;</td>
          <td class="paramname"><em>hostRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___audio___source.html#struct_a_r_a_audio_source_properties">ARAAudioSourceProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new audio source associated with the controller's document. The newly created audio source has its sample data access initially disabled, an explicit call to <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ab05b440d0590981cf47c37171b0e0af7" title="Enable or disable access to a given audio source. This call allows the host to control the time when ...">enableAudioSourceSamplesAccess()</a> is needed. </p>

</div>
</div>
<a id="a7c657674b5851eb2434069ed31d917f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c657674b5851eb2434069ed31d917f3">&#9670;&nbsp;</a></span>createAudioSourceContentReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a> ARA::PlugIn::DocumentControllerInterface::createAudioSourceContentReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a content reader for the given audio source and content type. This should only be called after availability has been confirmed using <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a3f6b668d86c92e6e3e2a2025d5e61782" title="Query whether the given content type is currently available for the given audio source.">isAudioSourceContentAvailable()</a>. The time range may be NULL, which means that the entire audio source shall be read. If a time range is specified, all events that at least partially intersect with the range will be read. </p>

</div>
</div>
<a id="afbf1dac990fca8f6284887a503452580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf1dac990fca8f6284887a503452580">&#9670;&nbsp;</a></span>createMusicalContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a> ARA::PlugIn::DocumentControllerInterface::createMusicalContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___musical___context.html#ga43976cbd88a15e2b89d66ea2c019619b">ARAMusicalContextHostRef</a>&#160;</td>
          <td class="paramname"><em>hostRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___musical___context.html#struct_a_r_a_musical_context_properties">ARAMusicalContextProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new musical context associated with the controller's document. </p>

</div>
</div>
<a id="aa31a4ce868b0eed7673a2148fd47cc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31a4ce868b0eed7673a2148fd47cc9a">&#9670;&nbsp;</a></span>createPlaybackRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> ARA::PlugIn::DocumentControllerInterface::createPlaybackRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td>
          <td class="paramname"><em>audioModificationRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___playback___region.html#ga69daf0d4cf4ca3cf9acf2874ca1dc682">ARAPlaybackRegionHostRef</a>&#160;</td>
          <td class="paramname"><em>hostRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___playback___region.html#struct_a_r_a_playback_region_properties">ARAPlaybackRegionProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new playback region associated with the given audio modification. </p>

</div>
</div>
<a id="a989865481ef057fa37c2ddb31460ebd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989865481ef057fa37c2ddb31460ebd0">&#9670;&nbsp;</a></span>createPlaybackRegionContentReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a> ARA::PlugIn::DocumentControllerInterface::createPlaybackRegionContentReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a>&#160;</td>
          <td class="paramname"><em>playbackRegionRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a content reader for the given playback region and content type. This should only be called after availability has been confirmed using <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a89060490e5c0855c90e8257557ab12f5" title="Query whether the given content type is currently available for the given playback region.">isPlaybackRegionContentAvailable()</a>. The time range may be NULL, which means that the entire playback region shall be read, including its potential head and tail time. If a time range is specified, all events that at least partially intersect with the range will be read. The time range must be given in playback time, and the time stamps provided by the content reader are in playback time as well. </p>

</div>
</div>
<a id="acf846c0e444863caaea4d8dd26ef38c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf846c0e444863caaea4d8dd26ef38c0">&#9670;&nbsp;</a></span>createRegionSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a> ARA::PlugIn::DocumentControllerInterface::createRegionSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___region___sequences.html#gae00b011383547d39b0ad55e2e908a248">ARARegionSequenceHostRef</a>&#160;</td>
          <td class="paramname"><em>hostRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___region___sequences.html#struct_a_r_a_region_sequence_properties">ARARegionSequenceProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new region sequence associated with the controller's document. </p>

</div>
</div>
<a id="a0a04ee4787a1a8607062993121494a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a04ee4787a1a8607062993121494a06">&#9670;&nbsp;</a></span>deactivateAudioModificationForUndoHistory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::deactivateAudioModificationForUndoHistory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td>
          <td class="paramname"><em>audioModificationRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deactivate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deactivate the given audio modification because it has become part of the undo history and is no longer used actively. The plug-in may free some memory that is only needed when the audio modification can be edited or rendered. Before deactivating an audio modification, the host must destroy all associated playback regions, and the opposite order is required when re-activating upon redo. When deactivated, updating the properties of the audio modification or reading its content is no longer valid. Like properties, deactivation is not necessarily persistent in the plug-in, so the host must call this explicitly when restoring deactivated audio modifications. Note that with the introduction of partial persistency with ARA 2.0, hosts likely will prefer to simply create partial archives of deleted audio modifications and manage these in their undo history rather than utilizing this call. </p>

</div>
</div>
<a id="aefe1e7f19bbfabc5c07e65f7011c166c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe1e7f19bbfabc5c07e65f7011c166c">&#9670;&nbsp;</a></span>deactivateAudioSourceForUndoHistory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::deactivateAudioSourceForUndoHistory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deactivate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deactivate the given audio source because it has become part of the undo history and is no longer used actively. The plug-in will cancel any pending analysis for this audio source and may free memory that is only needed when the audio source can be edited or rendered. Before deactivating an audio source, the host must deactivate all associated audio modifications, and the opposite order is required when re-activating upon redo. When deactivated, updating the properties or content of the audio source or reading its content is no longer valid. Like properties, deactivation is not necessarily persistent in the plug-in, so the host must call this explicitly when restoring deactivated audio sources. Note that with the introduction of partial persistency with ARA 2.0, hosts likely will prefer to simply create partial archives of deleted audio sources and manage these in their undo history rather than utilizing this call. </p>

</div>
</div>
<a id="ada10dd7c658e9f9e7d75ea7cbeb21c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada10dd7c658e9f9e7d75ea7cbeb21c55">&#9670;&nbsp;</a></span>destroyAudioModification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::destroyAudioModification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td>
          <td class="paramname"><em>audioModificationRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a given audio modification. Destroying an audio modification also implies removing it from its audio source. The host must delete all objects associated with the audio modification (playback regions etc.) before deleting the audio modification. </p>

</div>
</div>
<a id="ac4acb7d30b6ebdb7be57e32a1442e5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4acb7d30b6ebdb7be57e32a1442e5d8">&#9670;&nbsp;</a></span>destroyAudioSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::destroyAudioSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a given audio source. Destroying an audio source also implies removing it from its document. The host must delete all objects associated with the audio source (audio modifications etc.) before deleting the audio source. The host does not need to explicitly disable access to the audio source before making this call. </p>

</div>
</div>
<a id="a26c7d43a402ffaa74dd0c5bd60bce5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c7d43a402ffaa74dd0c5bd60bce5b6">&#9670;&nbsp;</a></span>destroyContentReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::destroyContentReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a>&#160;</td>
          <td class="paramname"><em>contentReaderRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the given content reader. </p>

</div>
</div>
<a id="a05ca7a307630db52948a9c15b00d678b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ca7a307630db52948a9c15b00d678b">&#9670;&nbsp;</a></span>destroyDocumentController()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::destroyDocumentController </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the controller and its associated document. The host must delete all objects associated with the document graph (audio sources, musical contexts etc.) before making this call. Note that the objects exported via the <a class="el" href="group___plug-_in___extension.html#struct_a_r_a_plug_in_extension_instance" title="The plug-in extension instance struct and all interfaces and refs therein must remain valid until the...">ARAPlugInExtensionInstance</a> are not considered part of the document graph, their destruction may happen before or after destroying the document controller that they are bound to. </p>

</div>
</div>
<a id="a66ad68c4bc81d87e3ef571622481d322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ad68c4bc81d87e3ef571622481d322">&#9670;&nbsp;</a></span>destroyMusicalContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::destroyMusicalContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a>&#160;</td>
          <td class="paramname"><em>musicalContextRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a given musical context. Destroying a musical context also implies removing it from its document. The musical context must no longer be referred to by any playback region when making this call. </p>

</div>
</div>
<a id="ac417aebba9b55025c124ab95df280229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac417aebba9b55025c124ab95df280229">&#9670;&nbsp;</a></span>destroyPlaybackRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::destroyPlaybackRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a>&#160;</td>
          <td class="paramname"><em>playbackRegionRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a given playback region. Destroying a playback region also implies removing it from its audio modification. The playback region must no longer be referred to by any plug-in extension when making this call. </p>

</div>
</div>
<a id="a051d5d411938547e18df8ba873655ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051d5d411938547e18df8ba873655ead">&#9670;&nbsp;</a></span>destroyRegionSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::destroyRegionSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a>&#160;</td>
          <td class="paramname"><em>regionSequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a given region sequence. The region sequence must no longer be referred to by any playback region when making this call. </p>

</div>
</div>
<a id="ab05b440d0590981cf47c37171b0e0af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05b440d0590981cf47c37171b0e0af7">&#9670;&nbsp;</a></span>enableAudioSourceSamplesAccess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::enableAudioSourceSamplesAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable access to a given audio source. This call allows the host to control the time when the plug-in may access sample data from the given audio source. Disabling access forces the plug-in to destroy all audio readers it currently has created for the affected audio source. This is a synchronous call, blocking until all currently executing reads of the audio source are finished. Access is disabled by default, hosts must explicitly enable it after creating an audio source. Since this call does not modify the model graph, it may be called outside the usual <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> scope. Note that disabling access will also abort any analysis currently being executed for the audio source, making it necessary to start it from scratch when the access is enabled again. This means that <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ab05b440d0590981cf47c37171b0e0af7" title="Enable or disable access to a given audio source. This call allows the host to control the time when ...">enableAudioSourceSamplesAccess()</a> is an expensive call that only should be made when necessary. It should not be (ab-)used to simply "pause ARA" whenever convenient. </p>

</div>
</div>
<a id="a40d465eb57035ff705d9576aa7bb63a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d465eb57035ff705d9576aa7bb63a6">&#9670;&nbsp;</a></span>endEditing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::endEditing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End an editing session on a document. Note that when receiving this call, the plug-in will update any amount of internal state. These edits may lead to update notifications to the host, and the host may in turn read affected content from the plug-in and update its own model accordingly. One example for this the way that Melodyne maintains chords and scales associated with audio modifications. It copies this data from the musical context into the audio modifications, so that when editing regions the notes appear in the proper pitch grid. If moving playback regions in the song, these copies may need to be updated, and Melodyne will report the resulting audio modification content changes to the host. To ensure that any such follow-up updates are added to the same undo cycle, hosts that actively read plug-in content data should immediately (i.e. within the same undo frame) call <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#adbfe7b9261ae7834d4a315427a248867" title="Tell the plug-in to send all pending update notifications for the given document. This must be called...">notifyModelUpdates()</a> after making this call. </p>

</div>
</div>
<a id="a7970f534bad94cf77c4de7ed74aad07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7970f534bad94cf77c4de7ed74aad07e">&#9670;&nbsp;</a></span>getAudioModificationContentGrade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___content___readers__and___content___events.html#ga91aa126b597a1b08dfcd01b2778ab734">ARAContentGrade</a> ARA::PlugIn::DocumentControllerInterface::getAudioModificationContentGrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td>
          <td class="paramname"><em>audioModificationRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the current quality of the information provided for a given audio modification and content type. Note that since ARA 2.0, reading at playback region level is recommended for most content types, see <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acbe985f9a890a092acd5bf25b2f02620" title="Create a content reader for the given audio modification and content type. This should only be called...">createAudioModificationContentReader()</a>. </p>

</div>
</div>
<a id="a920d4417abbc218175253107f549a37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920d4417abbc218175253107f549a37f">&#9670;&nbsp;</a></span>getAudioSourceContentGrade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___content___readers__and___content___events.html#ga91aa126b597a1b08dfcd01b2778ab734">ARAContentGrade</a> ARA::PlugIn::DocumentControllerInterface::getAudioSourceContentGrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the current quality of the information provided for the given audio source and content type. </p>

</div>
</div>
<a id="af05ff58332cddc0f6d0f86c82367376b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05ff58332cddc0f6d0f86c82367376b">&#9670;&nbsp;</a></span>getContentReaderDataForEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* ARA::PlugIn::DocumentControllerInterface::getContentReaderDataForEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a>&#160;</td>
          <td class="paramname"><em>contentReaderRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a>&#160;</td>
          <td class="paramname"><em>eventIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query data of the given event of the given reader. The returned pointer is owned by the plug-in and must remain valid until either <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#af05ff58332cddc0f6d0f86c82367376b" title="Query data of the given event of the given reader. The returned pointer is owned by the plug-in and m...">getContentReaderDataForEvent()</a> is called again or the content reader is destroyed. </p>

</div>
</div>
<a id="acaf328d061fde206ee89a3fc5ba6b12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf328d061fde206ee89a3fc5ba6b12b">&#9670;&nbsp;</a></span>getContentReaderEventCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a> ARA::PlugIn::DocumentControllerInterface::getContentReaderEventCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a>&#160;</td>
          <td class="paramname"><em>contentReaderRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query how many events the given reader exposes. </p>

</div>
</div>
<a id="a7e665f2e7434c5a6e2250519050e643f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e665f2e7434c5a6e2250519050e643f">&#9670;&nbsp;</a></span>getPlaybackRegionContentGrade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___model___content___readers__and___content___events.html#ga91aa126b597a1b08dfcd01b2778ab734">ARAContentGrade</a> ARA::PlugIn::DocumentControllerInterface::getPlaybackRegionContentGrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a>&#160;</td>
          <td class="paramname"><em>playbackRegionRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the current quality of the information provided for the given playback region and content type. </p>

</div>
</div>
<a id="a9024878882385a7196b27d906045359c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9024878882385a7196b27d906045359c">&#9670;&nbsp;</a></span>getPlaybackRegionHeadAndTailTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::getPlaybackRegionHeadAndTailTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a>&#160;</td>
          <td class="paramname"><em>playbackRegionRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___common__time-related__data__types.html#gaae0f11efaa1db78be29766f7bb5627f1">ARATimeDuration</a> *&#160;</td>
          <td class="paramname"><em>headTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___common__time-related__data__types.html#gaae0f11efaa1db78be29766f7bb5627f1">ARATimeDuration</a> *&#160;</td>
          <td class="paramname"><em>tailTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the current head and tail time of a given playback region. Note that when a plug-in optimizes region transitions, the head and tail of any given region can change upon any model edit, even if it is not directly affected by the edit. Also, in order to properly track interaction between regions, plug-ins may lazily update this information upon <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. Plug-ins will call notifyPlaybackRegionContentChanged() whenever these values change. headTime and tailTime must not be NULL. Host may query this often, so plug-ins should cache the value if there's any expensive calculation involved. Note that most companion APIs also feature a tail time concept. For playback renderer plug-in instances, the tail time reported via the companion API should be equal to or greater than the maximum of the tail times of all playback regions currently associated with the given renderer (i.e. the tail for any given playback region may be somewhat shorter then the companion API tail, depending on the region's content). </p>

</div>
</div>
<a id="ad41f25add1e6db62f694f1ae39eca55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41f25add1e6db62f694f1ae39eca55e">&#9670;&nbsp;</a></span>getProcessingAlgorithmForAudioSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a> ARA::PlugIn::DocumentControllerInterface::getProcessingAlgorithmForAudioSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query currently used processing algorithm for a given audio source. This method must be implemented if <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad24ed42f1feab6d7f44cba062a4881eb" title="Return the count of processing algorithms provided by the plug-in. If this optional method is not imp...">getProcessingAlgorithmsCount()</a> is implemented. After the plug-in has concluded an analysis (as indicated via <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a>), the host can query which processing algorithm was used and update its UI accordingly. This is particularly relevant if the host did explicitly request an analysis with a specific algorithm, but the plug-in was unable to satisfy this request for some reason. Similarly, the user may have changed the algorithm through the plug-in's UI. Note that until the first analysis has completed (i.e. as long as <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a39a8065750baed88c555dfeea75c49b8" title="Query whether an analysis of the given content type has been done for the given audio source....">isAudioSourceContentAnalysisIncomplete()</a> returns kARATrue), the value returned here may be an abstract default, not related to the actual audio source content. This will e.g. typically be the case in Melodyne, which uses an "automatic mode" as default until the first analysis has determined the actual processing algorithm that is suitable for the material. The call should not be made while <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a39a8065750baed88c555dfeea75c49b8" title="Query whether an analysis of the given content type has been done for the given audio source....">isAudioSourceContentAnalysisIncomplete()</a> returns kARATrue, because the returned value is likely stale. </p>

</div>
</div>
<a id="ad9b3ae6c5b508ff1f84cee58b2a7d661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b3ae6c5b508ff1f84cee58b2a7d661">&#9670;&nbsp;</a></span>getProcessingAlgorithmProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group___processing___algorithm___selection.html#struct_a_r_a_processing_algorithm_properties">ARAProcessingAlgorithmProperties</a>* ARA::PlugIn::DocumentControllerInterface::getProcessingAlgorithmProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a>&#160;</td>
          <td class="paramname"><em>algorithmIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of processing algorithms provided by the plug-in, described by their properties. This method must be implemented if <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad24ed42f1feab6d7f44cba062a4881eb" title="Return the count of processing algorithms provided by the plug-in. If this optional method is not imp...">getProcessingAlgorithmsCount()</a> is implemented. Provides a unique identifier and a user-readable name of the algorithm as displayed in the plug-in. The host should present the algorithms to the user in the order of this list, e.g. in a menu. For a given version of the plug-in, the count and the order and values of the persistentIDs must be the same, while the names may depend on localization settings that can be different on different machines or between individual runs of the host. The list may however change between different versions of the plug-in. Both hosts and plug-ins must implement fallbacks for loading a document that contains an processing algorithm persistentID which is no longer supported by the plug-in. The pointers returned by this calls must remain valid until the document controller is destroyed. </p>

</div>
</div>
<a id="ad24ed42f1feab6d7f44cba062a4881eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24ed42f1feab6d7f44cba062a4881eb">&#9670;&nbsp;</a></span>getProcessingAlgorithmsCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a> ARA::PlugIn::DocumentControllerInterface::getProcessingAlgorithmsCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the count of processing algorithms provided by the plug-in. If this optional method is not implemented or the call returns 0, then the plug-in does not support algorithm selection through the host and the other related functions below must not be called. </p>

</div>
</div>
<a id="a29380f8543b7017d8e86c78c66fd9659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29380f8543b7017d8e86c78c66fd9659">&#9670;&nbsp;</a></span>isAudioModificationContentAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ARA::PlugIn::DocumentControllerInterface::isAudioModificationContentAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td>
          <td class="paramname"><em>audioModificationRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the given content type is currently available for the given audio modification. Note that since ARA 2.0, reading at playback region level is recommended for most content types, see <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#acbe985f9a890a092acd5bf25b2f02620" title="Create a content reader for the given audio modification and content type. This should only be called...">createAudioModificationContentReader()</a>. </p>

</div>
</div>
<a id="ad5c2222fa0743555fc3c2258ec8a0a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c2222fa0743555fc3c2258ec8a0a51">&#9670;&nbsp;</a></span>isAudioModificationPreservingAudioSourceSignal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ARA::PlugIn::DocumentControllerInterface::isAudioModificationPreservingAudioSourceSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td>
          <td class="paramname"><em>audioModificationRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some hosts such as Pro Tools provide indicators whether a given plug-in's current settings cause it to alter the sound of the original audio source, or preserve it so that bypassing/removing the plug-in would not change the perceived audible result (note that actual rendering involves using a playback region, which still may apply time-stretching or pitch-shifting to the audio modification's potentially unaltered output).  <br>                               Changes to this state are tracked via <a class="el" href="group___host___model___update___controller___interface.html#af8ff42d436d6a83fe7605f06e49e6b52" title="Message to the host when content of the given audio modification changes. Not to be called if the cha...">ARAModelUpdateControllerInterface::notifyAudioModificationContentChanged()</a> with <a class="el" href="group___model___content___updates.html#gga74195b82b008866a82ca9dc2d226485ca34fb9ac9367757d532012c08185eac8b" title="The actual signal is unaffected by the change. Note that in some cases even when the signal is consid...">kARAContentUpdateSignalScopeRemainsUnchanged</a> == false. Note that it is possible to perform other edits such as reassigning the chords associated with the audio modification which would not affect this state.  <br>                               It is valid for plug-in implementations to deliver false negatives here to reasonably limit the cost of maintaining the state. For example, if the plug-in does some threshold-based processing, but the signal happens to never actually reach the threshold, the plug-in still may report to alter the sound. Another example is pitch&amp;time editing in a Melodyne-like plug-in: if notes are moved to a different pitch or time position so that this flag is cleared, but later the user manually moves them back to the original location, this might not cause this flag to turn back on. If however the user invokes undo, or some explicit reset command instead of the manual adjustment, then the plug-in should maintain this state properly. </p>

</div>
</div>
<a id="a39a8065750baed88c555dfeea75c49b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a8065750baed88c555dfeea75c49b8">&#9670;&nbsp;</a></span>isAudioSourceContentAnalysisIncomplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ARA::PlugIn::DocumentControllerInterface::isAudioSourceContentAnalysisIncomplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>contentType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether an analysis of the given content type has been done for the given audio source. This call will typically be used when the host uses the plug-in as a detection engine in the background (i.e. without presenting the UI to the user). In that scenario, the host will trigger the analysis of the desired content types using <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7227828433c385f53d108c5021c1d310" title="Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine,...">requestAudioSourceContentAnalysis()</a> and then wait until the plug-in calls <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a>. From that call, the host will query the plug-in via <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a39a8065750baed88c555dfeea75c49b8" title="Query whether an analysis of the given content type has been done for the given audio source....">isAudioSourceContentAnalysisIncomplete()</a> to determine which of the analysis requests have completed. If the host did request a specific algorithm to be used, then the plug-in should return kARATrue here until the request was satisfied (or rejected). </p>

</div>
</div>
<a id="a3f6b668d86c92e6e3e2a2025d5e61782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6b668d86c92e6e3e2a2025d5e61782">&#9670;&nbsp;</a></span>isAudioSourceContentAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ARA::PlugIn::DocumentControllerInterface::isAudioSourceContentAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the given content type is currently available for the given audio source. </p>

</div>
</div>
<a id="a4f64c3f76f2081c0354f8e3d791cd3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f64c3f76f2081c0354f8e3d791cd3ad">&#9670;&nbsp;</a></span>isLicensedForCapabilities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ARA::PlugIn::DocumentControllerInterface::isLicensedForCapabilities </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>runModalActivationDialogIfNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a>&#160;</td>
          <td class="paramname"><em>contentTypesCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>contentTypes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___playback___region.html#ga258336ff5f674225e3ec403493461179">ARAPlaybackTransformationFlags</a>&#160;</td>
          <td class="paramname"><em>transformationFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>With this optional call, hosts can test whether the current license state of the plug-in allows for requesting analysis of the given content types and rendering the given playback transformations (see <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7227828433c385f53d108c5021c1d310" title="Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine,...">requestAudioSourceContentAnalysis()</a> and <a class="el" href="group___model___playback___region.html#a3886d84f7b2a1915afd61ffdca08d8a7" title="Configuration of possible transformations upon playback, i.e. time-stretching etc....">ARAPlaybackRegionProperties::transformationFlags</a>). The host can also optionally instruct the plug-in to run a modal licensing dialog if the current license is not sufficient to perform the selected engine tasks, so that the user can review and adjust the licensing accordingly, such downloading a license from their respective user account or even purchase an upgrade that enables the requested features.  <br>                               The provided content types must be a subset of the plug-in's <a class="el" href="group___plug-_in___factory.html#abdefa00d5ef9074c3563d58265361525" title="Variable-sized C array listing the content types for which the plug-in can perform an analysis....">ARAFactory::analyzeableContentTypes</a>. To request all analysis types exported by the plug-in, hosts can directly pass analyzeableContentTypes and -Count from the <a class="el" href="group___plug-_in___factory.html#struct_a_r_a_factory" title="Static plug-in factory. All pointers herein must remain valid as long as the binary is loaded....">ARAFactory</a>. The contentTypes pointer may be only valid for the duration of the call, it must be evaluated inside the call, and the pointer must not be stored anywhere. If not intending to use analysis, the count should be 0 and the array pointer NULL. The transformationFlags must be a subset of the plug-in's <a class="el" href="group___plug-_in___factory.html#ad86be852472fa25593b8801c4ade263a" title="Set of transformations that the plug-in supports when configuring playback regions....">ARAFactory::supportedPlaybackTransformationFlags</a>, and may be kARAPlaybackTransformationNoChanges if not intending to use transformations. The call returns kARATrue if the (potentially updated) license is sufficient to perform the requested tasks. </p>

</div>
</div>
<a id="a89060490e5c0855c90e8257557ab12f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89060490e5c0855c90e8257557ab12f5">&#9670;&nbsp;</a></span>isPlaybackRegionContentAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ARA::PlugIn::DocumentControllerInterface::isPlaybackRegionContentAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a>&#160;</td>
          <td class="paramname"><em>playbackRegionRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the given content type is currently available for the given playback region. </p>

</div>
</div>
<a id="adbfe7b9261ae7834d4a315427a248867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfe7b9261ae7834d4a315427a248867">&#9670;&nbsp;</a></span>notifyModelUpdates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::notifyModelUpdates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the plug-in to send all pending update notifications for the given document. This must be called periodically by the host whenever not editing nor restoring the document. Only when processing this call, the plug-in may call back into the host using <a class="el" href="group___host___model___update___controller___interface.html#struct_a_r_a_model_update_controller_interface" title="Host interface: model update controller. As with all host interfaces, the function pointers in this s...">ARAModelUpdateControllerInterface</a>. Hosts must be aware after receiving <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a>, plug-ins may choose to postpone any subset of their internal state updates until the matching call to <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. This means that if the host for some reason needs to wait for a specific update in the plug-in to occur (such as waiting for an analysis to finish) it must do so outside of pairs of <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. </p>

</div>
</div>
<a id="a7227828433c385f53d108c5021c1d310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7227828433c385f53d108c5021c1d310">&#9670;&nbsp;</a></span>requestAudioSourceContentAnalysis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::requestAudioSourceContentAnalysis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a>&#160;</td>
          <td class="paramname"><em>contentTypesCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a>&#160;</td>
          <td class="paramname"><em>contentTypes</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine, it needs to explicitly trigger the desired analysis, since otherwise the plug-in may postpone any analysis as suitable. To allow for optimizing the analysis on the plug-in side, all content types that are of interest for the host should be specified in a single call if possible.  <br>                               Note that the plug-in may choose to perform any additional analysis at any point in time if this is appropriate for its design. It will call <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a> if such an analysis concludes successfully so that the host can update accordingly.  <br>                               The provided content types must be a non-empty subset of the plug-in's <a class="el" href="group___plug-_in___factory.html#abdefa00d5ef9074c3563d58265361525" title="Variable-sized C array listing the content types for which the plug-in can perform an analysis....">ARAFactory::analyzeableContentTypes</a>. To request all analysis types exported by the plug-in, hosts can directly pass analyzeableContentTypes and -Count from the plug-in's <a class="el" href="group___plug-_in___factory.html#struct_a_r_a_factory" title="Static plug-in factory. All pointers herein must remain valid as long as the binary is loaded....">ARAFactory</a>. The contentTypes pointer may be only valid for the duration of the call, it must be evaluated inside the call, and the pointer must not be stored anywhere.  <br>                               Note that ARA 2.0 adds the capability for the host to also request the use of a certain processing algorithm via <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a838c453c28cf96694e3002aedfec924b" title="Request that any future analysis of the given audio source should use the given processing algorithm....">requestProcessingAlgorithmForAudioSource()</a> - if both are used then the algorithm must be selected before requesting the analysis. </p>

</div>
</div>
<a id="a838c453c28cf96694e3002aedfec924b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838c453c28cf96694e3002aedfec924b">&#9670;&nbsp;</a></span>requestProcessingAlgorithmForAudioSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::requestProcessingAlgorithmForAudioSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a>&#160;</td>
          <td class="paramname"><em>algorithmIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request that any future analysis of the given audio source should use the given processing algorithm. This method must be implemented if <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ad24ed42f1feab6d7f44cba062a4881eb" title="Return the count of processing algorithms provided by the plug-in. If this optional method is not imp...">getProcessingAlgorithmsCount()</a> is implemented. This both affects any analysis requested by the host via <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a7227828433c385f53d108c5021c1d310" title="Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine,...">requestAudioSourceContentAnalysis()</a> as well as any analysis done by the plug-in on demand. Since this typically results in a model graph edit, calling this functions must be guarded by <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. Note that the plug-in is not required to heed this request if its internal state suggest otherwise, or if the user switches actively to a different algorithm. Also, some algorithms may be "meta" algorithms that will be replaced by a different actual algorithm, such as the "automatic" default algorithm in Melodyne which will pick an appropriate algorithm from the remaining list of algorithms when doing the initial analysis. </p>

</div>
</div>
<a id="a439a668fb1f0db06d06df534b13c9054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439a668fb1f0db06d06df534b13c9054">&#9670;&nbsp;</a></span>restoreObjectsFromArchive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ARA::PlugIn::DocumentControllerInterface::restoreObjectsFromArchive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___host___archiving___controller.html#ga05025b209d04967af019d599e4cf5838">ARAArchiveReaderHostRef</a>&#160;</td>
          <td class="paramname"><em>archiveReaderHostRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_restore_objects_filter">ARARestoreObjectsFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unarchive the internal state of the specified objects. This call can be used both for unarchiving entire documents and for importing arbitrary objects into an existing document. An unarchiving session is conceptually identical to an editing session: after starting the session, the host rebuilds the graph using the regular object creation calls, then makes this call to let the plug-in parse the archive and inject the archived internal state into the graph as indicated by the persistentIDs of the relevant objects. Similarly, when importing objects, the host will perform an editing session and either create new objects or re-use existing objects (potentially adjusting their persistentID), then make this call to inject the imported state.  <br>                               The optional filter allows for restoring only a subset of the archived states into the graph. It can be NULL, in which case all archived states with matching persistentIDs will be restored. In that case, the call sequence <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a931bd74210ce6ec6abeb07fabaf4383a" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a>, <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a439a668fb1f0db06d06df534b13c9054" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">restoreObjectsFromArchive()</a>, <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> is equivalent to the deprecated begin-/endRestoringDocumentFromArchive() for ARA 1, which has been superseded by this call. The host is not required to restore all objects in the archive. Any archived states that are either filtered explicitly, or for which there is no object with a matching persistent ID in the current graph are simply ignored. Since persistent IDs are only required to be unique per document (and not globally), hosts may encounter persistent ID conflicts when importing data from other documents. The optional <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_restore_objects_filter" title="Optional filter when restoring objects.  &lt;br&gt;                               \newline                 ...">ARARestoreObjectsFilter</a> provided for this call therefore allows to map between the IDs used in the archive and those used in the current graph if needed.  <br>                               The host can make multiple calls to <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a439a668fb1f0db06d06df534b13c9054" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">restoreObjectsFromArchive()</a> within the same editing session to import objects from multiple archives in one operation. It may even decide to implement its persistency based on partial archives entirely, using several calls to <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a8e0264b139236a7ea2b3959c49f594fe" title="Create a partial archive of the internal state of the specified objects. Archives may only be created...">storeObjectsToArchive()</a> with varying filters to split the document into slices appropriate to its implementation, see <a class="el" href="group___partial___document___persistency.html#a24ecfb6be6f94eed4038ea9d6ac202ea" title="Flag to indicate whether the plug-in should include its private, opaque document state in the archive...">ARAStoreObjectsFilter::documentData</a>.  <br>                               Result is kARAFalse if the access to the archive reader failed while trying to read the archive, or if decoding the data failed, kARATrue otherwise. Potential reason for failure include data corruption due to storage hardware failures, or broken dependencies when restoring partial archives as discussed above. The plug-in should try to recover as much state as possible in all cases, and the host should notify the user of such errors. If a failure happened already while reading the archive, the host is aware of this and can augment its error message to the user accordingly. If the failure happens inside the plug-in when decoding the data, the plug-in is responsible for guiding the user as good as possible, e.g. by listing or marking the affected objects. Note that since versioning is expressed through the ARA factory, the host must deal with potential versioning conflicts before making this call, and provide proper UI too. </p>

</div>
</div>
<a id="a91b6aac6ce3b6db7547058fe6a2e305f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b6aac6ce3b6db7547058fe6a2e305f">&#9670;&nbsp;</a></span>storeAudioSourceToAudioFileChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ARA::PlugIn::DocumentControllerInterface::storeAudioSourceToAudioFileChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___host___archiving___controller.html#gac673356af66f264ace3fb7c694e22c86">ARAArchiveWriterHostRef</a>&#160;</td>
          <td class="paramname"><em>archiveWriterHostRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___object___references.html#ga4debd59b541464cf35ccfd48ed8d6e68">ARAPersistentID</a> *&#160;</td>
          <td class="paramname"><em>documentArchiveID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>openAutomatically</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an archive of the internal state of the specified audio source suitable to be embedded into the underlying audio file as ARA audio file chunks, see <a class="el" href="group___a_r_a_audio_file_chunks.html">ARA Audio File Chunks</a>. Hosts must check <a class="el" href="group___plug-_in___factory.html#a109051a3e886c9522ea4dd03ffc34fc3" title="Flag whether the plug-in supports exporting ARA audio file chunks via ARADocumentControllerInterface:...">ARAFactory::supportsStoringAudioFileChunks</a> before enabling users to store audio file chunks for the given plug-in. Archives may only be created from documents that are not being currently edited.  <br>                               This call differs from using <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a8e0264b139236a7ea2b3959c49f594fe" title="Create a partial archive of the internal state of the specified objects. Archives may only be created...">storeObjectsToArchive()</a> with an <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_store_objects_filter" title="Optional filter when storing objects.  &lt;br&gt;                               \newline                   ...">ARAStoreObjectsFilter</a> in that the plug-in may choose a different internal encoding more suitable for this use case, indicated by returning a <code>documentArchiveID</code> that is likely one of the <a class="el" href="group___plug-_in___factory.html#ad086f2eb62f7a90a0ea6fa22f5ea6f78" title="Variable-sized C array listing other identifiers of archives that the document controller can import....">ARAFactory::compatibleDocumentArchiveIDs</a> rather than the <a class="el" href="group___plug-_in___factory.html#adebff6774723eb0490324afdcb2a993d" title="Identifier for document archives created by the document controller. This ID must be globally unique ...">ARAFactory::documentArchiveID</a>. The plug-in also returns whether openAutomatically should be set in the audio file chunk. Result is kARAFalse if the access to the archive writer failed while trying to write the archive, kARATrue otherwise. The host is responsible for alerting the user about archive write errors, see <a class="el" href="group___host___archiving___controller.html#a39ccce1c9ea18b0303e5633c8b0ddefd" title="Write bytes. This may only be called from storeObjectsToArchive() or the deprecated storeDocumentToAr...">ARAArchivingControllerInterface::writeBytesToArchive()</a>. </p>

</div>
</div>
<a id="a8e0264b139236a7ea2b3959c49f594fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0264b139236a7ea2b3959c49f594fe">&#9670;&nbsp;</a></span>storeObjectsToArchive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ARA::PlugIn::DocumentControllerInterface::storeObjectsToArchive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___host___archiving___controller.html#gac673356af66f264ace3fb7c694e22c86">ARAArchiveWriterHostRef</a>&#160;</td>
          <td class="paramname"><em>archiveWriterHostRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_store_objects_filter">ARAStoreObjectsFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a partial archive of the internal state of the specified objects. Archives may only be created from documents that are not being currently edited. The optional filter allows for storing only a subset of the document graph into the archive. It can be NULL, in which case all objects in the graph will be stored. In that case, the call is equivalent to the deprecated storeDocumentToArchive(), which has been superseded by this call. Result is kARAFalse if the access to the archive writer failed while trying to write the archive, kARATrue otherwise. The host is responsible for alerting the user about archive write errors, see <a class="el" href="group___host___archiving___controller.html#a39ccce1c9ea18b0303e5633c8b0ddefd" title="Write bytes. This may only be called from storeObjectsToArchive() or the deprecated storeDocumentToAr...">ARAArchivingControllerInterface::writeBytesToArchive()</a>. Note that for creating ARA audio file chunk archives, <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a91b6aac6ce3b6db7547058fe6a2e305f" title="Create an archive of the internal state of the specified audio source suitable to be embedded into th...">storeAudioSourceToAudioFileChunk()</a> must be used instead, so that the plug-in can pick the correct encoding and return the corresponding (compatible) document archive ID. </p>

</div>
</div>
<a id="a92710846f657ab433d3b284d4395c08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92710846f657ab433d3b284d4395c08f">&#9670;&nbsp;</a></span>updateAudioModificationProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::updateAudioModificationProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>&#160;</td>
          <td class="paramname"><em>audioModificationRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___audio___modification.html#struct_a_r_a_audio_modification_properties">ARAAudioModificationProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the properties of a given audio modification. All properties must be specified, the plug-in will determine which have actually changed. </p>

</div>
</div>
<a id="a0f90d2a38540e8b732b4120c5c28a4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f90d2a38540e8b732b4120c5c28a4aa">&#9670;&nbsp;</a></span>updateAudioSourceContent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::updateAudioSourceContent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___utility___content___update___scopes.html#class_a_r_a_1_1_content_update_scopes">ContentUpdateScopes</a>&#160;</td>
          <td class="paramname"><em>scopeFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the plug-in that the sample data or content information for the given audio source has changed. Not to be called in response to <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a>. The time range may be NULL, this means that the entire audio source is affected. When implementing this call, remember to also flush any caches of the sampled data if needed (see <a class="el" href="group___model___content___updates.html#gga74195b82b008866a82ca9dc2d226485ca34fb9ac9367757d532012c08185eac8b" title="The actual signal is unaffected by the change. Note that in some cases even when the signal is consid...">kARAContentUpdateSignalScopeRemainsUnchanged</a>). Creating a new audio source always implies an initial content update for it, i.e. the host will call this function only for later content updates. Since audio sources are persistent, plug-ins should preferably postpone the initial content reading until <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a40d465eb57035ff705d9576aa7bb63a6" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> - if the host is restoring the audio source, this will remove the need to read initial content. </p>

</div>
</div>
<a id="a2a21c60ee264dff98e6e43cb79d6a700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a21c60ee264dff98e6e43cb79d6a700">&#9670;&nbsp;</a></span>updateAudioSourceProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::updateAudioSourceProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>&#160;</td>
          <td class="paramname"><em>audioSourceRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___audio___source.html#struct_a_r_a_audio_source_properties">ARAAudioSourceProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the properties of a given audio source. Depending on which properties are changed (see documentation of <a class="el" href="group___model___audio___source.html#struct_a_r_a_audio_source_properties" title="Audio source properties. Note that like all properties, a pointer to this struct is only valid for th...">ARAAudioSourceProperties</a>), the host may not be able to make this call while the plug-in is reading data - in that case, use <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ab05b440d0590981cf47c37171b0e0af7" title="Enable or disable access to a given audio source. This call allows the host to control the time when ...">enableAudioSourceSamplesAccess()</a> accordingly. All properties must be specified, the plug-in will determine which have actually changed. </p>

</div>
</div>
<a id="a9bc1bbf67a6be2937256998c3beaaf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc1bbf67a6be2937256998c3beaaf95">&#9670;&nbsp;</a></span>updateDocumentProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::updateDocumentProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___document.html#struct_a_r_a_document_properties">ARADocumentProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the properties of the controller's document. All properties must be specified, the plug-in will determine which have actually changed. </p>

</div>
</div>
<a id="a638c8f20d933518251dbb632dd91cb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638c8f20d933518251dbb632dd91cb07">&#9670;&nbsp;</a></span>updateMusicalContextContent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::updateMusicalContextContent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a>&#160;</td>
          <td class="paramname"><em>musicalContextRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___utility___content___update___scopes.html#class_a_r_a_1_1_content_update_scopes">ContentUpdateScopes</a>&#160;</td>
          <td class="paramname"><em>scopeFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the plug-in to update the information obtainable via content readers for a given musical context. The time range may be NULL, this means that the entire musical content is affected. Creating a new musical context implies an initial content update for it - the host will call this explicitly only for later content updates. </p>

</div>
</div>
<a id="a20016bea45d1e69dc231a58d6cb0fd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20016bea45d1e69dc231a58d6cb0fd7e">&#9670;&nbsp;</a></span>updateMusicalContextProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::updateMusicalContextProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a>&#160;</td>
          <td class="paramname"><em>musicalContextRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___musical___context.html#struct_a_r_a_musical_context_properties">ARAMusicalContextProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the properties of a given musical context. All properties must be specified, the plug-in will determine which have actually changed. </p>

</div>
</div>
<a id="a4e6a1c2291a89e0ceb8f3ae337ee2226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6a1c2291a89e0ceb8f3ae337ee2226">&#9670;&nbsp;</a></span>updatePlaybackRegionProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::updatePlaybackRegionProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a>&#160;</td>
          <td class="paramname"><em>playbackRegionRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___playback___region.html#struct_a_r_a_playback_region_properties">ARAPlaybackRegionProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the properties of a given playback region. All properties must be specified, the plug-in will determine which have actually changed. </p>

</div>
</div>
<a id="a4e99fc888036753212353dbafccf0e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e99fc888036753212353dbafccf0e5f">&#9670;&nbsp;</a></span>updateRegionSequenceProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::DocumentControllerInterface::updateRegionSequenceProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a>&#160;</td>
          <td class="paramname"><em>regionSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___plug_in___dispatch.html#ga2e2a73fb8a1840a2b6ea92e667134825">PropertiesPtr</a>&lt; <a class="el" href="group___model___region___sequences.html#struct_a_r_a_region_sequence_properties">ARARegionSequenceProperties</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the properties of a given region sequence. All properties must be specified, the plug-in will determine which have actually changed. </p>

</div>
</div>

</div>
</div>
<a name="class_a_r_a_1_1_plug_in_1_1_document_controller_instance" id="class_a_r_a_1_1_plug_in_1_1_document_controller_instance"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_a_r_a_1_1_plug_in_1_1_document_controller_instance">&#9670;&nbsp;</a></span>ARA::PlugIn::DocumentControllerInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ARA::PlugIn::DocumentControllerInstance</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Wrapper class for the <a class="el" href="group___plug-_in___document___controller___instance.html#struct_a_r_a_document_controller_instance" title="The document controller instance struct and all interfaces and refs therein must remain valid until t...">ARADocumentControllerInstance</a>. </p>
</div><div class="dynheader">
Inheritance diagram for ARA::PlugIn::DocumentControllerInstance:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___a_r_a___library___host___dispatch___plug-_in___interfaces.png" usemap="#ARA::PlugIn::DocumentControllerInstance_map" alt=""/>
  <map id="ARA::PlugIn::DocumentControllerInstance_map" name="ARA::PlugIn::DocumentControllerInstance_map">
<area href="group___a_r_a___library___utility___sized_structs.html" alt="ARA::SizedStruct&lt; ARA_STRUCT_MEMBER(ARADocumentControllerInstance, documentControllerInterface)&gt;" shape="rect" coords="0,0,630,24"/>
  </map>
</div></div>

</div>
</div>
<a name="class_a_r_a_1_1_plug_in_1_1_playback_renderer_interface" id="class_a_r_a_1_1_plug_in_1_1_playback_renderer_interface"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_a_r_a_1_1_plug_in_1_1_playback_renderer_interface">&#9670;&nbsp;</a></span>ARA::PlugIn::PlaybackRendererInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ARA::PlugIn::PlaybackRendererInterface</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Base class for implementing <a class="el" href="group___playback___renderer___interface.html#struct_a_r_a_playback_renderer_interface" title="Plug-in interface: playback renderer. The function pointers in this struct must remain valid until th...">ARAPlaybackRendererInterface</a>. </p>
</div><div class="dynheader">
Inheritance diagram for ARA::PlugIn::PlaybackRendererInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___a_r_a___library___host___dispatch___plug-_in___interfaces.png" usemap="#ARA::PlugIn::PlaybackRendererInterface_map" alt=""/>
  <map id="ARA::PlugIn::PlaybackRendererInterface_map" name="ARA::PlugIn::PlaybackRendererInterface_map">
<area href="group___a_r_a___library___a_r_a_plug___plug_in_instance_roles.html#class_a_r_a_1_1_plug_in_1_1_playback_renderer" title="Extensible plug-in instance role class implementing an ARA Playback Renderer Interface (Added In ARA ..." alt="ARA::PlugIn::PlaybackRenderer" shape="rect" coords="0,56,240,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Assigning the playback region(s) for playback rendering</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3b8bb83f8a92eef32dddacbd2bd05e9c"></a>For details, see <a class="el" href="group___playback___renderer___interface.html#Assigning_ARAPlaybackRendererInterface_Regions">ARAPlaybackRendererInterface</a>. </p>
</td></tr>
<tr class="memitem:aba84917e704f5e3ff89a3d39afffcab5"><td class="memItemLeft" align="right" valign="top"><a id="aba84917e704f5e3ff89a3d39afffcab5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addPlaybackRegion</b> (<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef) noexcept=0</td></tr>
<tr class="separator:aba84917e704f5e3ff89a3d39afffcab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f78374685e5f1593d4b3816e829aab8"><td class="memItemLeft" align="right" valign="top"><a id="a9f78374685e5f1593d4b3816e829aab8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removePlaybackRegion</b> (<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef) noexcept=0</td></tr>
<tr class="separator:a9f78374685e5f1593d4b3816e829aab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="class_a_r_a_1_1_plug_in_1_1_editor_renderer_interface" id="class_a_r_a_1_1_plug_in_1_1_editor_renderer_interface"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_a_r_a_1_1_plug_in_1_1_editor_renderer_interface">&#9670;&nbsp;</a></span>ARA::PlugIn::EditorRendererInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ARA::PlugIn::EditorRendererInterface</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Base class for implementing <a class="el" href="group___editor___renderer___interface.html#struct_a_r_a_editor_renderer_interface" title="Plug-in interface: editor renderer. The function pointers in this struct must remain valid until the ...">ARAEditorRendererInterface</a>. </p>
</div><div class="dynheader">
Inheritance diagram for ARA::PlugIn::EditorRendererInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___a_r_a___library___host___dispatch___plug-_in___interfaces.png" usemap="#ARA::PlugIn::EditorRendererInterface_map" alt=""/>
  <map id="ARA::PlugIn::EditorRendererInterface_map" name="ARA::PlugIn::EditorRendererInterface_map">
<area href="group___a_r_a___library___a_r_a_plug___plug_in_instance_roles.html#class_a_r_a_1_1_plug_in_1_1_editor_renderer" title="Extensible plug-in instance role class implementing an ARA Editor Renderer Interface (Added In ARA 2...." alt="ARA::PlugIn::EditorRenderer" shape="rect" coords="0,56,221,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Assigning the playback region(s) for preview while editing</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6e4545740d9b2b952962b920fab9562a"></a>For details, see <a class="el" href="group___editor___renderer___interface.html#Assigning_ARAEditorRendererInterface_Regions">ARAEditorRendererInterface</a>. </p>
</td></tr>
<tr class="memitem:ab66f2b06f95c80cb36168ef592f0e5ad"><td class="memItemLeft" align="right" valign="top"><a id="ab66f2b06f95c80cb36168ef592f0e5ad"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addPlaybackRegion</b> (<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef) noexcept=0</td></tr>
<tr class="separator:ab66f2b06f95c80cb36168ef592f0e5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ab575af660b4e80b1ba75a31390919"><td class="memItemLeft" align="right" valign="top"><a id="a45ab575af660b4e80b1ba75a31390919"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removePlaybackRegion</b> (<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef) noexcept=0</td></tr>
<tr class="separator:a45ab575af660b4e80b1ba75a31390919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e45d825e9140c0eb361ddcf02e4cef1"><td class="memItemLeft" align="right" valign="top"><a id="a9e45d825e9140c0eb361ddcf02e4cef1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addRegionSequence</b> (<a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a> regionSequenceRef) noexcept=0</td></tr>
<tr class="separator:a9e45d825e9140c0eb361ddcf02e4cef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b98239c3e5b10d2315687f11320159"><td class="memItemLeft" align="right" valign="top"><a id="a20b98239c3e5b10d2315687f11320159"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeRegionSequence</b> (<a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a> regionSequenceRef) noexcept=0</td></tr>
<tr class="separator:a20b98239c3e5b10d2315687f11320159"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="class_a_r_a_1_1_plug_in_1_1_editor_view_interface" id="class_a_r_a_1_1_plug_in_1_1_editor_view_interface"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_a_r_a_1_1_plug_in_1_1_editor_view_interface">&#9670;&nbsp;</a></span>ARA::PlugIn::EditorViewInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ARA::PlugIn::EditorViewInterface</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Base class for implementing <a class="el" href="group___editor___view___interface.html#struct_a_r_a_editor_view_interface" title="Plug-in interface: view controller. The function pointers in this struct must remain valid until the ...">ARAEditorViewInterface</a>. </p>
</div><div class="dynheader">
Inheritance diagram for ARA::PlugIn::EditorViewInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___a_r_a___library___host___dispatch___plug-_in___interfaces.png" usemap="#ARA::PlugIn::EditorViewInterface_map" alt=""/>
  <map id="ARA::PlugIn::EditorViewInterface_map" name="ARA::PlugIn::EditorViewInterface_map">
<area href="group___a_r_a___library___a_r_a_plug___plug_in_instance_roles.html#class_a_r_a_1_1_plug_in_1_1_editor_view" title="Extensible plug-in instance role class implementing an ARA Editor View Interface (Added In ARA 2...." alt="ARA::PlugIn::EditorView" shape="rect" coords="0,56,196,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Host UI notifications</h3></td></tr>
<tr class="memitem:a9d3eab5fa47d18a9f42a6176357ae229"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a9d3eab5fa47d18a9f42a6176357ae229">notifySelection</a> (<a class="el" href="group___a_r_a___library___utility___sized_structs.html#class_a_r_a_1_1_sized_struct_ptr">SizedStructPtr</a>&lt; <a class="el" href="group___editor___view___interface.html#struct_a_r_a_view_selection">ARAViewSelection</a> &gt; selection) noexcept=0</td></tr>
<tr class="memdesc:a9d3eab5fa47d18a9f42a6176357ae229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given host selection to all associated views. This ARA 2.0 addition allows hosts to translate the effects of their selection implementation to a selection of ARA objects that can be interpreted by the plug-in. The command is not strict a setter for the given selection state, it rather notifies the plug-in about relevant user interaction in the host so that it can adopt in whatever way provides the best user experience within the context of the given plug-in design. A plug-in may e.g. implement scrolling to relevant positions, select the playback regions in its inspector(s), or filter the provided objects further depending on user settings. The plug-in also remains free to modify its internal selection at any time through its build-in UI behavior. For example, a plug-in may design its UI around individual regions being edited, or around entire region sequences. Melodyne features both modes, switchable by the user. When editing an individual region, it will always pick the "most suitable" region from the selection, and ignore the other selected regions. Melodyne also implements various ways to switch the editable region sequence(s) or playback region at any time independently from the host selection, as well as a user option to temporarily ignore host selection changes to "pin" the current selection. The same "loose" coupling applies on the host side: the selection sent by the host is not necessarily equal to its actual selection, but rather the best representation of the users' intent. For example, the user may be able to select entities that are not directly represented in the ARA API, but relate to a set of playback regions in some meaningful way. In that case, those regions may be sent as selection. The selection command includes various optional entities that describe the selection on the host side, such as playback regions or region sequences. Host will only explicitly provide those objects that best describe their current selection, but plug-ins can often derive other selections from that, such as calculating a region selection based on sequence selection and time range. Most hosts offer both an object-based selection which typically centers around selected arrange events (playback regions) and tracks (region sequences) versus a time-range based selection that is independent of the arrange events but typically also includes track selection. Both modes shall be distinguished by providing a time range only in the latter case. Some hosts even allow to select multiple time ranges, this should be expressed by sending their union range across the API. For an object-based selection, the time range remains NULL, and plug-ins can calculate an implicit time range from the selected playback regions if desired. Arrange event selection may linked to track selection in a variety of ways. For example, selecting a track may select its events (often filter by playback cycle range), and selecting an event may select its associated track as well. The ARA selection must be always updated to reflect any such linking accordingly. In each object list, objects are ordered by importance, with the most relevant, "focused" object being first. So if a plug-in supports only a single region selection, it should use the first region. If it can only show a single region sequence at a time, it should use the first selected sequence, or if no sequences are included in the selection fall back to the sequence of the first selected region, etc. Each new selection call describes a full selection, i.e. replaces the previous selection. An empty selection is valid and should be communicated by the host, since some plug-ins may need to evaluate this in special cases. Being selected does not affect the life time of the objects - selected objects may be deleted without updating the selection status first. Note that a pointer to this struct and all pointers contained therein are only valid for the duration of the current call receiving the pointer - the data must be evaluated/copied inside the call, and the pointers must not be stored anywhere.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#a9d3eab5fa47d18a9f42a6176357ae229">More...</a><br /></td></tr>
<tr class="separator:a9d3eab5fa47d18a9f42a6176357ae229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8502dd829adc46a1f6b88f6ea1a528d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ab8502dd829adc46a1f6b88f6ea1a528d">notifyHideRegionSequences</a> (<a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a> regionSequenceRefsCount, const <a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a> regionSequenceRefs[]) noexcept=0</td></tr>
<tr class="memdesc:ab8502dd829adc46a1f6b88f6ea1a528d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflect hiding of region sequences in all associated views. Some hosts offer the option to hide arrange tracks from view, so that they are no longer visible, while still being played back regularly. This can be communicated to the plug-in so that it follows suite. Each call implicitly unhides all previously hidden region sequences, so calling this with an empty list makes all sequences visible. The regionSequenceRefs pointer is only valid for the duration of the call, it must be evaluated inside the call, and the pointer must not be stored anywhere. It should be NULL if regionSequenceRefsCount is 0.  <a href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#ab8502dd829adc46a1f6b88f6ea1a528d">More...</a><br /></td></tr>
<tr class="separator:ab8502dd829adc46a1f6b88f6ea1a528d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="ab8502dd829adc46a1f6b88f6ea1a528d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8502dd829adc46a1f6b88f6ea1a528d">&#9670;&nbsp;</a></span>notifyHideRegionSequences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::EditorViewInterface::notifyHideRegionSequences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a>&#160;</td>
          <td class="paramname"><em>regionSequenceRefsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a>&#160;</td>
          <td class="paramname"><em>regionSequenceRefs</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reflect hiding of region sequences in all associated views. Some hosts offer the option to hide arrange tracks from view, so that they are no longer visible, while still being played back regularly. This can be communicated to the plug-in so that it follows suite. Each call implicitly unhides all previously hidden region sequences, so calling this with an empty list makes all sequences visible. The regionSequenceRefs pointer is only valid for the duration of the call, it must be evaluated inside the call, and the pointer must not be stored anywhere. It should be NULL if regionSequenceRefsCount is 0. </p>

</div>
</div>
<a id="a9d3eab5fa47d18a9f42a6176357ae229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3eab5fa47d18a9f42a6176357ae229">&#9670;&nbsp;</a></span>notifySelection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ARA::PlugIn::EditorViewInterface::notifySelection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_r_a___library___utility___sized_structs.html#class_a_r_a_1_1_sized_struct_ptr">SizedStructPtr</a>&lt; <a class="el" href="group___editor___view___interface.html#struct_a_r_a_view_selection">ARAViewSelection</a> &gt;&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the given host selection to all associated views. This ARA 2.0 addition allows hosts to translate the effects of their selection implementation to a selection of ARA objects that can be interpreted by the plug-in. The command is not strict a setter for the given selection state, it rather notifies the plug-in about relevant user interaction in the host so that it can adopt in whatever way provides the best user experience within the context of the given plug-in design. A plug-in may e.g. implement scrolling to relevant positions, select the playback regions in its inspector(s), or filter the provided objects further depending on user settings. The plug-in also remains free to modify its internal selection at any time through its build-in UI behavior. For example, a plug-in may design its UI around individual regions being edited, or around entire region sequences. Melodyne features both modes, switchable by the user. When editing an individual region, it will always pick the "most suitable" region from the selection, and ignore the other selected regions. Melodyne also implements various ways to switch the editable region sequence(s) or playback region at any time independently from the host selection, as well as a user option to temporarily ignore host selection changes to "pin" the current selection. The same "loose" coupling applies on the host side: the selection sent by the host is not necessarily equal to its actual selection, but rather the best representation of the users' intent. For example, the user may be able to select entities that are not directly represented in the ARA API, but relate to a set of playback regions in some meaningful way. In that case, those regions may be sent as selection. The selection command includes various optional entities that describe the selection on the host side, such as playback regions or region sequences. Host will only explicitly provide those objects that best describe their current selection, but plug-ins can often derive other selections from that, such as calculating a region selection based on sequence selection and time range. Most hosts offer both an object-based selection which typically centers around selected arrange events (playback regions) and tracks (region sequences) versus a time-range based selection that is independent of the arrange events but typically also includes track selection. Both modes shall be distinguished by providing a time range only in the latter case. Some hosts even allow to select multiple time ranges, this should be expressed by sending their union range across the API. For an object-based selection, the time range remains NULL, and plug-ins can calculate an implicit time range from the selected playback regions if desired. Arrange event selection may linked to track selection in a variety of ways. For example, selecting a track may select its events (often filter by playback cycle range), and selecting an event may select its associated track as well. The ARA selection must be always updated to reflect any such linking accordingly. In each object list, objects are ordered by importance, with the most relevant, "focused" object being first. So if a plug-in supports only a single region selection, it should use the first region. If it can only show a single region sequence at a time, it should use the first selected sequence, or if no sequences are included in the selection fall back to the sequence of the first selected region, etc. Each new selection call describes a full selection, i.e. replaces the previous selection. An empty selection is valid and should be communicated by the host, since some plug-ins may need to evaluate this in special cases. Being selected does not affect the life time of the objects - selected objects may be deleted without updating the selection status first. Note that a pointer to this struct and all pointers contained therein are only valid for the duration of the current call receiving the pointer - the data must be evaluated/copied inside the call, and the pointers must not be stored anywhere. </p>

</div>
</div>

</div>
</div>
<a name="class_a_r_a_1_1_plug_in_1_1_plug_in_extension_instance" id="class_a_r_a_1_1_plug_in_1_1_plug_in_extension_instance"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_a_r_a_1_1_plug_in_1_1_plug_in_extension_instance">&#9670;&nbsp;</a></span>ARA::PlugIn::PlugInExtensionInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ARA::PlugIn::PlugInExtensionInstance</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Wrapper class for <a class="el" href="group___plug-_in___extension.html#struct_a_r_a_plug_in_extension_instance" title="The plug-in extension instance struct and all interfaces and refs therein must remain valid until the...">ARAPlugInExtensionInstance</a>. </p>
</div><div class="dynheader">
Inheritance diagram for ARA::PlugIn::PlugInExtensionInstance:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___a_r_a___library___host___dispatch___plug-_in___interfaces.png" usemap="#ARA::PlugIn::PlugInExtensionInstance_map" alt=""/>
  <map id="ARA::PlugIn::PlugInExtensionInstance_map" name="ARA::PlugIn::PlugInExtensionInstance_map">
<area href="group___a_r_a___library___utility___sized_structs.html" alt="ARA::SizedStruct&lt; ARA_STRUCT_MEMBER(ARAPlugInExtensionInstance, editorViewInterface)&gt;" shape="rect" coords="0,0,557,24"/>
  </map>
</div></div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
