<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARA SDK 2.2.0: Archiving Controller</title>
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="shortcut icon" sizes="16x16" href="./favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="DoxygenStyleSheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ARA_Logo.png" height="50px"/></td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___host___archiving___controller.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Archiving Controller<div class="ingroups"><a class="el" href="group___host___interfaces.html">Host Interfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This interface allows plug-ins to read and write archives with minimal memory impact. It also allows for displaying progress when archiving or unarchiving model graphs. Its functions may only be called during the archiving/unarchiving process.  <br>                               Because of the potentially large size of the archives, ARA does not use simple monolithic memory blocks as known from many companion APIs. Instead, it establishes a stream-like archive format so that copying large blocks of memory can be avoided. Plug-ins that create large archives should use any mean of data reduction that is appropriate to reduce the archive size. For example, they may implement gzip compression. Since it has good knowledge of the characteristics of the data, it can configure the compression algorithms so that optimal results are achieved. Consequently, there's no point for host to try to compress the data any further with generic algorithms.  <br>                               Hosts that support both 32 and 64 bit architectures shall be aware of the fact that ARA archive sizes are pointer-sized data types, so they will differ in bit width between these architectures. This must be taken into account when storing the archive size in the host's document structure. Also, when importing documents from 64 bit into 32 bit, the host must check whether the archive is small enough to be loaded at all (i.e. its size fits into 32 bits). If not, it shall refuse to load the archive and provide a proper error message. This may seem like a restriction, but the reasoning behind this is that if the archive already exceeds the available address space, the resulting unarchived graph will do so too.  <br>                               There's no creation or destruction call for the archive readers/writers because they are provided by the host for the duration of the (un-)archiving process, so the lifetime is implicitly defined.  <br>                               When using API generation 1 or older and loading an archive through the deprecated functions begin-/endRestoringDocumentFromArchive(), plug-ins may choose to access the associated archive reader upon either begin- or endRestoringDocumentFromArchive() or even upon both calls, as suitable for their implementation - hosts must be able to provide the requested data during the duration of both calls.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_archiving_controller_interface" title="Base class for implementing ARAArchivingControllerInterface.">ARA::Host::ArchivingControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_archiving_controller" title="Wrapper class for the ARAArchivingControllerInterface provided by the host.">ARA::PlugIn::HostArchivingController</a>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:struct_a_r_a_archiving_controller_interface"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html#struct_a_r_a_archiving_controller_interface">ARAArchivingControllerInterface</a></td></tr>
<tr class="memdesc:struct_a_r_a_archiving_controller_interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Host interface: archive controller. As with all host interfaces, the function pointers in this struct must remain valid until all document controllers on the plug-in side that use it have been destroyed.  <a href="group___host___archiving___controller.html#struct_a_r_a_archiving_controller_interface">More...</a><br /></td></tr>
<tr class="separator:struct_a_r_a_archiving_controller_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga32b62a9158bdaa9d8f9f5c39b5636f4d"><td class="memItemLeft" align="right" valign="top"><a id="ga32b62a9158bdaa9d8f9f5c39b5636f4d"></a>
typedef struct ARAArchivingControllerHostRefMarkupType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html#ga32b62a9158bdaa9d8f9f5c39b5636f4d">ARAArchivingControllerHostRef</a></td></tr>
<tr class="memdesc:ga32b62a9158bdaa9d8f9f5c39b5636f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the host side representation of an archiving controller (opaque to the plug-in). <br /></td></tr>
<tr class="separator:ga32b62a9158bdaa9d8f9f5c39b5636f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05025b209d04967af019d599e4cf5838"><td class="memItemLeft" align="right" valign="top"><a id="ga05025b209d04967af019d599e4cf5838"></a>
typedef struct ARAArchiveReaderHostRefMarkupType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html#ga05025b209d04967af019d599e4cf5838">ARAArchiveReaderHostRef</a></td></tr>
<tr class="memdesc:ga05025b209d04967af019d599e4cf5838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the host side representation of an archive reader (opaque to the plug-in). <br /></td></tr>
<tr class="separator:ga05025b209d04967af019d599e4cf5838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac673356af66f264ace3fb7c694e22c86"><td class="memItemLeft" align="right" valign="top"><a id="gac673356af66f264ace3fb7c694e22c86"></a>
typedef struct ARAArchiveWriterHostRefMarkupType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html#gac673356af66f264ace3fb7c694e22c86">ARAArchiveWriterHostRef</a></td></tr>
<tr class="memdesc:gac673356af66f264ace3fb7c694e22c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the host side representation of an archive writer (opaque to the plug-in). <br /></td></tr>
<tr class="separator:gac673356af66f264ace3fb7c694e22c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_a_r_a_archiving_controller_interface" id="struct_a_r_a_archiving_controller_interface"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_a_r_a_archiving_controller_interface">&#9670;&nbsp;</a></span>ARAArchivingControllerInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ARAArchivingControllerInterface</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Host interface: archive controller. As with all host interfaces, the function pointers in this struct must remain valid until all document controllers on the plug-in side that use it have been destroyed. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Size-based struct versioning</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8272db3aa4580fe6b7beb9697d0787b7"></a> See <a class="el" href="group___versioned__structs.html">Versioned structs</a>. </p>
</td></tr>
<tr class="memitem:ae38c5b2a7514e1da9790ea4533c80467"><td class="memItemLeft" align="right" valign="top"><a id="ae38c5b2a7514e1da9790ea4533c80467"></a>
<a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>structSize</b></td></tr>
<tr class="separator:ae38c5b2a7514e1da9790ea4533c80467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Reading Archives</h3></td></tr>
<tr class="memitem:af87337fb4aed748b4510fdba78f9aebd"><td class="memItemLeft" align="right" valign="top"><a id="af87337fb4aed748b4510fdba78f9aebd"></a>
<a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html#af87337fb4aed748b4510fdba78f9aebd">getArchiveSize</a> )(<a class="el" href="group___host___archiving___controller.html#ga32b62a9158bdaa9d8f9f5c39b5636f4d">ARAArchivingControllerHostRef</a> controllerHostRef, <a class="el" href="group___host___archiving___controller.html#ga05025b209d04967af019d599e4cf5838">ARAArchiveReaderHostRef</a> archiveReaderHostRef)</td></tr>
<tr class="memdesc:af87337fb4aed748b4510fdba78f9aebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size of the archive. This may only be called from <a class="el" href="group___plug-_in___document___controller.html#a6ad2b9f4070e12178057c3c9590f4c32" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">ARADocumentControllerInterface::restoreObjectsFromArchive()</a>, or if using API generation 1 from the deprecated begin-/endRestoringDocumentFromArchive() calls. Plug-ins must respect this size when reading the archive, reading beyond the end of the data is a programming error (and should thus be asserted by the host). <br /></td></tr>
<tr class="separator:af87337fb4aed748b4510fdba78f9aebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccf16b9aa652cb144271680f76bd063"><td class="memItemLeft" align="right" valign="top"><a id="abccf16b9aa652cb144271680f76bd063"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html#abccf16b9aa652cb144271680f76bd063">readBytesFromArchive</a> )(<a class="el" href="group___host___archiving___controller.html#ga32b62a9158bdaa9d8f9f5c39b5636f4d">ARAArchivingControllerHostRef</a> controllerHostRef, <a class="el" href="group___host___archiving___controller.html#ga05025b209d04967af019d599e4cf5838">ARAArchiveReaderHostRef</a> archiveReaderHostRef, <a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a> position, <a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a> length, <a class="el" href="group___fixed-size__integers.html#gaa05ee1c5aaac4d31b21a755c4b9169df">ARAByte</a> buffer[])</td></tr>
<tr class="memdesc:abccf16b9aa652cb144271680f76bd063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes. This may only be called from <a class="el" href="group___plug-_in___document___controller.html#a6ad2b9f4070e12178057c3c9590f4c32" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">ARADocumentControllerInterface::restoreObjectsFromArchive()</a>, or if using API generation 1 from the deprecated begin-/endRestoringDocumentFromArchive() calls. Result is kARATrue upon success, or kARAFalse when there is a critical, nonrecoverable I/O error, such as a network failure while the file is being read from a server. In case of failing in this call, the host must notify the user about the problem in some appropriate way. The archive will not be restored by the plug-in then, it'll fall back into some proper initial state for the affected objects. <br /></td></tr>
<tr class="separator:abccf16b9aa652cb144271680f76bd063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad579d210b318e345eae91b512f643a1a"><td class="memItemLeft" align="right" valign="top"><a id="ad579d210b318e345eae91b512f643a1a"></a>
<a class="el" href="group___object___references.html#ga4debd59b541464cf35ccfd48ed8d6e68">ARAPersistentID</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html#ad579d210b318e345eae91b512f643a1a">getDocumentArchiveID</a> )(<a class="el" href="group___host___archiving___controller.html#ga32b62a9158bdaa9d8f9f5c39b5636f4d">ARAArchivingControllerHostRef</a> controllerHostRef, <a class="el" href="group___host___archiving___controller.html#ga05025b209d04967af019d599e4cf5838">ARAArchiveReaderHostRef</a> archiveReaderHostRef)</td></tr>
<tr class="memdesc:ad579d210b318e345eae91b512f643a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the document archive ID that the plug-in's factory provided when saving the archive. This may only be called from <a class="el" href="group___plug-_in___document___controller.html#a6ad2b9f4070e12178057c3c9590f4c32" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">ARADocumentControllerInterface::restoreObjectsFromArchive()</a>. Plug-ins can use this information to optimize their unarchiving code in case different archive formats are used depending on document archive ID. The returned pointer is owned by the host and must remain valid until the archive reader is destroyed. All hosts that support kARAAPIGeneration_2_0_Final or newer must implement this call. <br /></td></tr>
<tr class="separator:ad579d210b318e345eae91b512f643a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Writing Archives</h3></td></tr>
<tr class="memitem:a39ccce1c9ea18b0303e5633c8b0ddefd"><td class="memItemLeft" align="right" valign="top"><a id="a39ccce1c9ea18b0303e5633c8b0ddefd"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html#a39ccce1c9ea18b0303e5633c8b0ddefd">writeBytesToArchive</a> )(<a class="el" href="group___host___archiving___controller.html#ga32b62a9158bdaa9d8f9f5c39b5636f4d">ARAArchivingControllerHostRef</a> controllerHostRef, <a class="el" href="group___host___archiving___controller.html#gac673356af66f264ace3fb7c694e22c86">ARAArchiveWriterHostRef</a> archiveWriterHostRef, <a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a> position, <a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a> length, const <a class="el" href="group___fixed-size__integers.html#gaa05ee1c5aaac4d31b21a755c4b9169df">ARAByte</a> buffer[])</td></tr>
<tr class="memdesc:a39ccce1c9ea18b0303e5633c8b0ddefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes. This may only be called from storeObjectsToArchive() or the deprecated storeDocumentToArchive(). Result is kARATrue upon success, or kARAFalse when there is a critical, nonrecoverable I/O error, such as a network failure while the file is being written to a server. In case of failing in this call, the host must notify the user about the problem in an appropriate way.  <br>                               Note that a plug-in should strive to write the data consecutively in a stream-like manner. Nevertheless, repositioning is needed to support chunk-style archives where the chunk length must be specified at the start of the chunk, but is not known until the chunk data has been fully created (and possibly compressed). In that case, the plug-in will need to "rewind" to the chunk size entry in the chunk header after writing the chunk and update it accordingly. As in most file APIs, any range of bytes that was skipped when writing should be filled with 0 by the host. <br /></td></tr>
<tr class="separator:a39ccce1c9ea18b0303e5633c8b0ddefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>(Un-)Archiving Progress Information</h3></td></tr>
<tr class="memitem:a56693e95882eb7e62cb928e0874ae860"><td class="memItemLeft" align="right" valign="top"><a id="a56693e95882eb7e62cb928e0874ae860"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html#a56693e95882eb7e62cb928e0874ae860">notifyDocumentArchivingProgress</a> )(<a class="el" href="group___host___archiving___controller.html#ga32b62a9158bdaa9d8f9f5c39b5636f4d">ARAArchivingControllerHostRef</a> controllerHostRef, float value)</td></tr>
<tr class="memdesc:a56693e95882eb7e62cb928e0874ae860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message to the host signaling document save progress, value ranges from 0.0f to 1.0f. This may only be called from storeObjectsToArchive() or from the deprecated storeDocumentToArchive(). In order to keep CPU load low, plug-ins should try to keep the update rate for this call as low as about 1000 calls per archive, which equals increments of 0.1%. <br /></td></tr>
<tr class="separator:a56693e95882eb7e62cb928e0874ae860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0f82f80e01f5b5da9b2f388cda8628"><td class="memItemLeft" align="right" valign="top"><a id="a7f0f82f80e01f5b5da9b2f388cda8628"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html#a7f0f82f80e01f5b5da9b2f388cda8628">notifyDocumentUnarchivingProgress</a> )(<a class="el" href="group___host___archiving___controller.html#ga32b62a9158bdaa9d8f9f5c39b5636f4d">ARAArchivingControllerHostRef</a> controllerHostRef, float value)</td></tr>
<tr class="memdesc:a7f0f82f80e01f5b5da9b2f388cda8628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message to the host signaling document save progress, value ranges from 0.0f to 1.0f. This may only be called from <a class="el" href="group___plug-_in___document___controller.html#a6ad2b9f4070e12178057c3c9590f4c32" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">ARADocumentControllerInterface::restoreObjectsFromArchive()</a>, or if using API generation 1 from the deprecated begin-/endRestoringDocumentFromArchive() and the associated model object creation/update calls guarded by them. In the deprecated form, the first call should be made from begin- and the last call from endRestoringDocumentFromArchive(). In order to keep CPU load low, plug-ins should try to keep the update rate for this call as low as about 1000 calls per archive, which equals increments of 0.1%. <br /></td></tr>
<tr class="separator:a7f0f82f80e01f5b5da9b2f388cda8628"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
