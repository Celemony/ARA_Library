<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARA SDK 2.2.0: Host Interfaces</title>
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="shortcut icon" sizes="16x16" href="./favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="DoxygenStyleSheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ARA_Logo.png" height="50px"/></td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___host___interfaces.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Subpages</a>  </div>
  <div class="headertitle">
<div class="title">Host Interfaces</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Subpages</h2></td></tr>
<tr class="memitem:group___host___audio___access___controller"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___audio___access___controller.html">Audio Access Controller</a></td></tr>
<tr class="memdesc:group___host___audio___access___controller"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface allows plug-ins to read the audio data from the host in a random access order. It is used from multiple threads, both host and plug-in need to carefully observe the threading rules for each function. The basic design idea is that each audio reader is used single-threaded, but multiple audio readers can work concurrently (even on the same audio source). Audio readers can be considered random access iterators, and like most iterators operate on conceptually constant data structures. If the host changes sample rate, channel count or other audio source properties that the reader relies upon, the plug-in must discard any existing audio readers for the source and later re-create them based on the new configuration. The host can temporarily disable access to the audio source in order to control the exact timing of stopping the readers from accessing the source. Whenever an audio reader is destroyed, the plug-in is responsible for thread safety - it may need to block until a concurrent read operation on the I/O thread has finished. Hosts must take care in their audio reader implementation to avoid potential deadlocks in this situation. Note that when rendering, the audio source will often not be read in a consecutive order - depending on the edits the user applied at audio modification level, the access may jump back and forth quite often. The reader implementation should be optimized accordingly.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_audio_access_controller_interface" title="Base class for implementing ARAAudioAccessControllerInterface.">ARA::Host::AudioAccessControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_audio_access_controller" title="Wrapper class for the ARAAudioAccessControllerInterface provided by the host.">ARA::PlugIn::HostAudioAccessController</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___host___archiving___controller"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___archiving___controller.html">Archiving Controller</a></td></tr>
<tr class="memdesc:group___host___archiving___controller"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface allows plug-ins to read and write archives with minimal memory impact. It also allows for displaying progress when archiving or unarchiving model graphs. Its functions may only be called during the archiving/unarchiving process.  <br>                               Because of the potentially large size of the archives, ARA does not use simple monolithic memory blocks as known from many companion APIs. Instead, it establishes a stream-like archive format so that copying large blocks of memory can be avoided. Plug-ins that create large archives should use any mean of data reduction that is appropriate to reduce the archive size. For example, they may implement gzip compression. Since it has good knowledge of the characteristics of the data, it can configure the compression algorithms so that optimal results are achieved. Consequently, there's no point for host to try to compress the data any further with generic algorithms.  <br>                               Hosts that support both 32 and 64 bit architectures shall be aware of the fact that ARA archive sizes are pointer-sized data types, so they will differ in bit width between these architectures. This must be taken into account when storing the archive size in the host's document structure. Also, when importing documents from 64 bit into 32 bit, the host must check whether the archive is small enough to be loaded at all (i.e. its size fits into 32 bits). If not, it shall refuse to load the archive and provide a proper error message. This may seem like a restriction, but the reasoning behind this is that if the archive already exceeds the available address space, the resulting unarchived graph will do so too.  <br>                               There's no creation or destruction call for the archive readers/writers because they are provided by the host for the duration of the (un-)archiving process, so the lifetime is implicitly defined.  <br>                               When using API generation 1 or older and loading an archive through the deprecated functions begin-/endRestoringDocumentFromArchive(), plug-ins may choose to access the associated archive reader upon either begin- or endRestoringDocumentFromArchive() or even upon both calls, as suitable for their implementation - hosts must be able to provide the requested data during the duration of both calls.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_archiving_controller_interface" title="Base class for implementing ARAArchivingControllerInterface.">ARA::Host::ArchivingControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_archiving_controller" title="Wrapper class for the ARAArchivingControllerInterface provided by the host.">ARA::PlugIn::HostArchivingController</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___host___model___content___access___controller"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___model___content___access___controller.html">Model Content Access Controller</a></td></tr>
<tr class="memdesc:group___host___model___content___access___controller"><td class="mdescLeft">&#160;</td><td class="mdescRight">This optional interface provides access to host model data such as the musical context. Its functions may only be called from ARADocumentControllerInterface.create...() or update...() for the object currently created/updated, or from <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">ARADocumentControllerInterface::endEditing()</a> for any object.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_content_access_controller_interface" title="Base class for implementing ARAContentAccessControllerInterface.">ARA::Host::ContentAccessControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_content_access_controller" title="Wrapper class for the ARAContentAccessControllerInterface by the host.">ARA::PlugIn::HostContentAccessController</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___host___model___update___controller___interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___model___update___controller___interface.html">Model Update Controller Interface</a></td></tr>
<tr class="memdesc:group___host___model___update___controller___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">This optional host interface allows the host to be notified about content changes in the plug-in. Its functions may only be called from <a class="el" href="group___plug-_in___document___controller.html#a0f37365379866cc1a596291f85fbcbe7" title="Tell the plug-in to send all pending update notifications for the given document. This must be called...">ARADocumentControllerInterface::notifyModelUpdates()</a>.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_model_update_controller_interface" title="Base class for implementing ARAModelUpdateControllerInterface.">ARA::Host::ModelUpdateControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_model_update_controller" title="Wrapper class for the ARAModelUpdateControllerInterface provided by the host.">ARA::PlugIn::HostModelUpdateController</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___host___playback___controller___interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___playback___controller___interface.html">Playback Controller Interface</a></td></tr>
<tr class="memdesc:group___host___playback___controller___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">This optional host interface allows the plug-in to request playback state changes. The functions in this interface may be called concurrently, but not from render-threads. The host may choose to ignore any of these requests. The requests will typically be scheduled and executed with some delay. The current state of playback is transmitted via the companion API.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_playback_controller_interface" title="Base class for implementing ARAPlaybackControllerInterface.">ARA::Host::PlaybackControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_playback_controller" title="Wrapper class for the ARAPlaybackControllerInterface provided by the host.">ARA::PlugIn::HostPlaybackController</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___host___document___controller___instance"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___host___document___controller___instance.html">Document Controller Instance</a></td></tr>
<tr class="memdesc:group___host___document___controller___instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callbacks into the host are published by the host when creating a document controller on the plug-in side to maintain an ARA model graph. The instance struct and all interfaces and host refs therein must remain valid until the document controller is destroyed. The host can choose to create its controller objects per document controller instance, or it can share a single instance between all document controllers, whatever fits its needs. It may even mix-and-match both approaches per individual interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
