<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARA SDK 2.2.0: Module Documentation</title>
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="shortcut icon" sizes="16x16" href="./favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="DoxygenStyleSheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ARA_Logo.png" height="50px"/></td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('modules.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Module Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">Here is a list of all modules:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span><span onclick="javascript:toggleLevel(3);">3</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_0_" class="arrow" onclick="toggleFolder('0_')">&#9660;</span><a class="el" href="group___basic___types.html" target="_self">Basic Types</a></td><td class="desc">Pre-defined types to ensure binary compatibility between plug-in and host. These types must be used when crossing the API boundary, but intermediate types can be used internally. For example, you can use your own struct representing color, but when defining color for ARA operations your internal color struct must be converted to <a class="el" href="group___color.html#struct_a_r_a_color" title="R/G/B color, values range from 0.0f to 1.0f. Does not include transparency because it must not depend...">ARAColor</a> </td></tr>
<tr id="row_0_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___fixed-size__integers.html" target="_self">Fixed-size Integers</a></td><td class="desc">ARA defines platform-independent signed integers with fixed size of 32 or 64 bits and for a pointer-sized signed integer </td></tr>
<tr id="row_0_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___boolean__values.html" target="_self">Boolean Values</a></td><td class="desc">Since Microsoft still doesn't fully support C99 and fails to provide &lt;stdbool.h&gt;, we need to roll our own. On the other hand this ensures a fixed size of 32 bits, too. 32 bits were chosen so that ARABool is consistent with the other enum-like data types such as ARAContentType. Since ARABool is only used in temporary structs that are valid only for the duration of a call and likely passed in a register in most cases, there's no point in trying to optimize for size by using 8 bit boolean types. Note that in order to avoid conversion warnings in Visual Studio, you should not directly cast bool to ARABool or vice versa, but instead use a ternary operator or a comparison like this: </td></tr>
<tr id="row_0_2_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___enums.html" target="_self">Enums</a></td><td class="desc">ARA enums can either be used to represent distinct enumerations, or to declare C-compatible constant integer flags that can be or'd together as bit masks. To ensure binary compatibility between plug-in and host, the underlying type of ARA enums is always ARAInt32 </td></tr>
<tr id="row_0_3_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___strings.html" target="_self">Strings</a></td><td class="desc">User-readable texts are stored as UTF-8 encoded unicode strings. It's not defined if and how the string is normalized - if either side has requirements regarding normalization, it needs to apply these after reading the string from the other side. Unicode rules apply regarding normalization, comparison etc. Both hosts and plug-ins are required to support at least all ISO/IEC 8859-1 based characters (from U+0020 up to U+007E and from U+00A0 up to U+00FF) in their text display rendering </td></tr>
<tr id="row_0_4_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___common__time-related__data__types.html" target="_self">Common Time-Related Data Types</a></td><td class="desc">Some basic data types used in several contexts </td></tr>
<tr id="row_0_5_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___sampled__audio__data.html" target="_self">Sampled Audio Data</a></td><td class="desc">The audio samples are encoded using these format descriptions. The data alignment and byte order always matches the machine's native layout </td></tr>
<tr id="row_0_6_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___color.html" target="_self">Color</a></td><td class="desc">ARA color representation </td></tr>
<tr id="row_0_7_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___object___references.html" target="_self">Object References</a></td><td class="desc">ARA uses pointer-sized unique identifiers to reference objects at runtime - typical C++-based implementations will use the this-pointer as ID. C-style code could do the same, or instead choose to use array indices as ID. <br>                               Those objects that are archived by the host can be persistently identified by an <a class="el" href="group___object___references.html#ga4debd59b541464cf35ccfd48ed8d6e68" title="Persistent object reference representation. Persistent IDs are used to encode object references betwe...">ARAPersistentID</a> that the host assigns as a property of the object </td></tr>
<tr id="row_1_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_1_" class="arrow" onclick="toggleFolder('1_')">&#9660;</span><a class="el" href="group___a_p_i__versions.html" target="_self">API Versions</a></td><td class="desc">ARA implements two patterns for its ongoing evolution of the API: incremental, fully-backwards compatible additions by appending features to it versioned structs, and major, potentially incompatible updates through its API generations </td></tr>
<tr id="row_1_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___a_p_i__generations.html" target="_self">API Generations</a></td><td class="desc">While purely additive features can be handled through ARA's versioned structs, ARA API generations allow for non-backwards-compatible, fundamental API changes. For hosts that rely on a certain minimum ARA feature set provided by the plug-ins, it also offers a convenient way to filter incompatible plug-ins. Plug-ins on the other hand can use the API generation chosen by the host to optimize their feature set for the given environment, such as disabling potentially costly fallback code required for older hosts when running in a modern host </td></tr>
<tr id="row_1_1_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___versioned__structs.html" target="_self">Versioned Structs</a></td><td class="desc">In the various interface and data structs used in the ARA API, callback pointers or data fields may be added in later revisions of the current API generation. Each of these extensible structs starts with a structSize data field that describes how much data is actually contained in the given instance of the struct, thus allowing to determine which of the additional features are supported by the other side. All struct members that are later additions will be marked with the macro ARA_ADDENDUM. Members that are not marked as addendum must always be present in the struct. Accordingly, the minimum value of structSize is the size of the struct in the first API revision. When creating such a struct in your code, the maximum value is the size of the struct in the current API revision used at compile time. When parsing a struct received from the other side, the value may be even larger since the other side may use an even later API revision.  <br>                               Note that when implementing ARA, it is important not to directly use sizeof() when filling in the structSize values. If you later update to newer API headers, the values of sizeof() will change and your code thus will be broken until you've implemented all additions. Instead, use the ARA_IMPLEMENTED_STRUCT_SIZE macro or similar techniques added in the ARA C++ library dispatcher code, see <a class="el" href="group___a_r_a___library___utility___sized_structs.html">there</a> </td></tr>
<tr id="row_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group___debugging.html" target="_self">Debugging</a></td><td class="desc">ARA strictly separates programming errors from runtime error conditions such as missing files, CPU or I/O overloads etc. Runtime errors occur when accessing external data and resources, which is always done on the host side of the ARA API. Accordingly, the host has the responsibility to detect any such errors and to properly communicate the issue to the user. Since ARA leverages existing technologies, host implementations usually already feature proper code for this. With the error reporting done on the host side, plug-ins do not need to know any details about runtime errors - a simple bool to indicate success or failure is sufficient for implementing normal operation or graceful error recovery. Thus, ARA does not need to define error codes for communicating error details across the API. As an example, consider audio data being read from a server across the network - if the connection breaks, the host will recognize the issue and bring up an according user notification. If the plug-in requests the now inaccessible audio data, the host simply flags that an error occurred and the plug-in can either retry later or use silence as fallback data.  <br>                               A different kind of errors are programming errors. If either side fails to properly follow the API contract, undefined behavior can occur. Tracking down such bugs from one side only can be difficult and very time consuming, thus ARA strives to aid developers in this process by defining a global assert function that both sides call whenever detecting programming errors related to the ARA API. When debugging (or when running unit tests), either side can provide the code for the assert function, so that no matter what side you're debugging from you can always inject your custom assert handling in order to be able to set proper breakpoints etc. The assert function is only a debug facility: it will usually be disabled on end user systems, and it must never be used for flow control in a shipping product. Instead, each side should implement graceful fallback behavior after asserting the programming error, e.g. by defining a special value for invalid object refs (NULL or -1, depending on the implementation) which will be returned as a placeholder whenever object creation fails due to a programming error on the other side and then filtering this value accordingly whenever objects are referenced </td></tr>
<tr id="row_3_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_3_" class="arrow" onclick="toggleFolder('3_')">&#9660;</span><a class="el" href="group___a_r_a___model___graph.html" target="_self">ARA Model Graph</a></td><td class="desc"></td></tr>
<tr id="row_3_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___document.html" target="_self">Document</a></td><td class="desc">The document is the root object for a model graph and typically represents a piece of music such as a song or an entire performance. It is bound to a document controller in a 1:1 relationship. The document controller is used to manage the entire graph it contains. Because of the 1:1 relationship, the document is never specified when calling into the document controller. Edits of the document and any of the objects it contains are done in cycles started with <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">ARADocumentControllerInterface::beginEditing()</a> and concluded with <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">ARADocumentControllerInterface::endEditing()</a>. This allows plug-ins to deal with any render thread synchronization that may be necessary, as well as postponing any internal updates until the end of the cycle when the ARA graph has its full state available. A document is the root object for persistency and is the owner of any amount of associated audio sources, region sequences and musical contexts.  <br>                               Plug-in developers using the C++ ARA Library can use the <a class="el" href="group___a_r_a___library___a_r_a_plug___model___objects.html#class_a_r_a_1_1_plug_in_1_1_document" title="Extensible model object class representing an ARA Document.">ARA::PlugIn::Document</a> class </td></tr>
<tr id="row_3_1_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___musical___context.html" target="_self">Musical Context</a></td><td class="desc">A musical context describes both rhythmical concepts of the music such as bars and beats and their distribution over time, as well as harmonic structures and their distribution over time. A musical context is always owned by one document. Musical contexts are not persistent when storing documents, instead the host re-creates them as needed.  <br>                               Plug-in developers using the C++ ARA Library can use the <a class="el" href="group___a_r_a___library___a_r_a_plug___model___objects.html#class_a_r_a_1_1_plug_in_1_1_musical_context" title="Extensible model object class representing an ARA Musical Context.">ARA::PlugIn::MusicalContext</a> class </td></tr>
<tr id="row_3_2_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___region___sequences.html" target="_self">Region Sequences (Added In ARA 2.0)</a></td><td class="desc">Region sequences allow hosts to group playback regions, typically by "tracks" or "lanes" in their arrangement. Each sequence is associated with a musical context, and all regions in a sequence will be adapted to that same context. Further, all regions within a sequence are expected to play back through the same routing (incl. same latency), typically the same "mixer track" or "audio channel". Regions in a sequence can overlap, and such overlapping regions will sound concurrently. A region sequence is always owned by one document, and refers to a musical context. Region sequences are not persistent when storing documents, instead the host re-creates them as needed.  <br>                               Plug-in developers using the C++ ARA Library can use the <a class="el" href="group___a_r_a___library___a_r_a_plug___model___objects.html#class_a_r_a_1_1_plug_in_1_1_region_sequence" title="Extensible model object class representing an ARA Region Sequences (Added In ARA 2....">ARA::PlugIn::RegionSequence</a> class </td></tr>
<tr id="row_3_3_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___audio___source.html" target="_self">Audio Source</a></td><td class="desc">An audio source represents a continuous sequence of sampled audio data. Typically a host will create an audio source object for each audio file used with ARA plug-ins. Conceptually, the contents of an audio source are immutable (even though updates are possible, this is an expensive process, and user edits based on the modified content may get lost). An audio source is always owned by one document, and in turn owns any amount of associated audio modifications. Audio sources are persistent when storing documents.  <br>                               Plug-in developers using the C++ ARA Library can use the <a class="el" href="group___a_r_a___library___a_r_a_plug___model___objects.html#class_a_r_a_1_1_plug_in_1_1_audio_source" title="Extensible model object class representing an ARA Audio Source.">ARA::PlugIn::AudioSource</a> class </td></tr>
<tr id="row_3_4_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___audio___modification.html" target="_self">Audio Modification</a></td><td class="desc">An audio modification contains a set of musical edits that the user has made to transform the content of an audio source when rendered by the ARA plug-in. An audio modification is always owned by one audio source, and in turn owns any amount of associated playback regions. Audio modifications are persistent when storing documents.  <br>                               Plug-in developers using the C++ ARA Library can use the <a class="el" href="group___a_r_a___library___a_r_a_plug___model___objects.html#class_a_r_a_1_1_plug_in_1_1_audio_modification" title="Extensible model object class representing an ARA Audio Modification.">ARA::PlugIn::AudioModification</a> class </td></tr>
<tr id="row_3_5_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___playback___region.html" target="_self">Playback Region</a></td><td class="desc">A playback region is a reference to an arbitrary time section of an audio modification, mapped to a certain section of playback time. It is linked to a region sequence, which in turn is linked to a musical context. All playback regions that share the same audio modification play back the same musical content, but may adapt that content to the given section of the musical context and to the content of other regions in the same region sequence (see content based fades). Note that if a plug-in offers any user settings to control this adaptation (such as groove settings), then these settings should be part of the audio modification state, not of the individual playback regions. A playback is always owned by one audio modification, and refers to a region sequence. Playback regions are not persistent when storing documents, instead the host re-creates them as needed.  <br>                               Plug-in developers using the C++ ARA Library can use the <a class="el" href="group___a_r_a___library___a_r_a_plug___model___objects.html#class_a_r_a_1_1_plug_in_1_1_playback_region" title="Extensible model object class representing an ARA Playback Region.">ARA::PlugIn::PlaybackRegion</a> class </td></tr>
<tr id="row_4_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_4_" class="arrow" onclick="toggleFolder('4_')">&#9660;</span><a class="el" href="group___content___reading.html" target="_self">Content Reading</a></td><td class="desc"></td></tr>
<tr id="row_4_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___content___updates.html" target="_self">Content Updates</a></td><td class="desc"> <br>                               There are several levels of abstraction when analyzing musical recordings. Initially, there is the signal in its "physical" form. On the next level, the signal interpreted as a series of musical events - the notes played when creating the signal. These notes and their relationship in time and pitch can be interpreted further, leading to abstractions like tempo, bar signatures, key signatures, tuning and chords.  <br>                               Updates may happen on any of these levels, both independently or concurrently. In the most simple but most unlikely case, the signal is completely replaced, and all the higher abstractions therefore also invalidated. This also means that all user edits done in an audio modification will be lost. More likely is a minor modification of the signal, such as applying a high pass filtering to remove rumble in the audio source. This will not change any higher abstractions (all notes etc. remain the same), so any edits inside the audio modification or any notation of the music based on the analysis will remain intact. Another case is the correction of the analysis by the user. The signal does not change in this case, but mis-detected notes are added or removed so the mid-level abstraction which is considered with the notes changes. Whether or not this also changes higher interpretations such as the detected harmonic structure depends on the case at hand.  <br>                               ARA defines a set of flags that allow to communicate the level of change, which helps to avoid unnecessary flushing of the user edits inside an audio modification and allows for optimizations of the analysis. The flags are providing a guarantee what has NOT changed. This may seem odd at first but if for example a given host does not know about harmonies, it cannot make any assumption about whether these have changed or not </td></tr>
<tr id="row_4_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___content___readers__and___content___events.html" target="_self">Content Readers And Content Events</a></td><td class="desc"> <br>                               Reading content description follows the same pattern both from the host and from the plug-in side. ARA establishes iterator objects called content reader to access the data in small units called content events. There are several types available, each defining a certain abstract representation of its associated events.  <br>                               Upon creation, content readers are bound to a given content type and to an object of which the content shall be read. Optionally the reader can be restricted to only cover a given time range. Once created, its event count is queried and the individual events are read, then the reader is disposed of. This is all done immediately, reader objects are only temporary objects that are created and destroyed from the same stack frame.  <br>                               The data pointer returned when reading an event's data remains owned by the content reader and must remain valid until the reader is either another event is read or the reader is destroyed.  <br>                               The events returned by the reader are sorted in an order that depends on the content type, but generally follows their appearance on the timeline. If several events appear at the same (start-)time, their order is not defined and the receiver must apply further sorting if desired.  <br>                               The C++ ARA Library offers convenient content reader classes for host and plug-in developers. Host developers can read plug-in content using ARA::Host::ContentReader, and plug-in developers can use <a class="el" href="group___a_r_a___library___a_r_a_plug___utility___classes.html#class_a_r_a_1_1_plug_in_1_1_host_content_reader" title="Utility class that wraps the host ARAContentAccessControllerInterface.">ARA::PlugIn::HostContentReader</a> to read host content </td></tr>
<tr id="row_4_2_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___timeline.html" target="_self">Timeline</a></td><td class="desc"> <br>                               ARA expresses musical timing as a mapping between song time measured in seconds and musical time measured in quarter notes. The mapping is created by dividing the timeline into sections of constant musical tempo. These tempo sections are then annotated as a list of tempo sync points, where each point represents both the end of one and the beginning of another section. The location of a tempo sync point is specified both in song time and musical time. The actual tempo of a section can be easily derived from the relationship of the duration of the section in song time and the duration of the section in musical time (note that neither the quarters nor the seconds must necessarily be integer values here): </td></tr>
<tr id="row_4_3_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___notes.html" target="_self">Notes</a></td><td class="desc"> <br>                               Notes in ARA correspond to what a composer would notate to describe the music. Notes are described by their position in time, their pitch and their relative volume. The pitch can be interpreted as frequency, but ARA also offers a musical description of the pitch very similar to MIDI: it defines the tuning for the overall musical scale and provides an integer number to identify the pitch for each note within this tuning, along with an average detune for each note actually played. ARA pitch numbers match MIDI note numbers, so that the note A4 has the value 69. This note is also used to specify the tuning reference, commonly at 440 Hz. At 440 Hz reference tuning the ARA pitch number 0 thus equals 8.1757989 Hz. Some notes may not have a well-defined pitch, such as percussive notes. For such notes, a frequency of kARAInvalidFrequency and a pitch number of kARAInvalidPitchNumber are used </td></tr>
<tr id="row_4_4_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___model___tuning___key___signatures__and___chords.html" target="_self">Tuning, Key Signatures and Chords (Added In ARA 2.0)</a></td><td class="desc"> <br>                               ARA expresses "western standard" octave-cyclic, 12-tone scales as tunings and key signatures. While some applications such as Melodyne offer a much more complex model that allows for acyclic and/or micro-tonal scales, those models usually don't map well to each others, and introduce a complexity that can not meaningfully be handled by applications with the "main stream" model. Further, there is no standardized musical theory for expressing chords in such scales. Should the actual need to deal with more complex scales arise in the future, a new content type may be added to cover this </td></tr>
<tr id="row_5_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_5_" class="arrow" onclick="toggleFolder('5_')">&#9660;</span><a class="el" href="group___host___interfaces.html" target="_self">Host Interfaces</a></td><td class="desc"></td></tr>
<tr id="row_5_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___host___audio___access___controller.html" target="_self">Audio Access Controller</a></td><td class="desc">This interface allows plug-ins to read the audio data from the host in a random access order. It is used from multiple threads, both host and plug-in need to carefully observe the threading rules for each function. The basic design idea is that each audio reader is used single-threaded, but multiple audio readers can work concurrently (even on the same audio source). Audio readers can be considered random access iterators, and like most iterators operate on conceptually constant data structures. If the host changes sample rate, channel count or other audio source properties that the reader relies upon, the plug-in must discard any existing audio readers for the source and later re-create them based on the new configuration. The host can temporarily disable access to the audio source in order to control the exact timing of stopping the readers from accessing the source. Whenever an audio reader is destroyed, the plug-in is responsible for thread safety - it may need to block until a concurrent read operation on the I/O thread has finished. Hosts must take care in their audio reader implementation to avoid potential deadlocks in this situation. Note that when rendering, the audio source will often not be read in a consecutive order - depending on the edits the user applied at audio modification level, the access may jump back and forth quite often. The reader implementation should be optimized accordingly.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_audio_access_controller_interface" title="Base class for implementing ARAAudioAccessControllerInterface.">ARA::Host::AudioAccessControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_audio_access_controller" title="Wrapper class for the ARAAudioAccessControllerInterface provided by the host.">ARA::PlugIn::HostAudioAccessController</a> </td></tr>
<tr id="row_5_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___host___archiving___controller.html" target="_self">Archiving Controller</a></td><td class="desc">This interface allows plug-ins to read and write archives with minimal memory impact. It also allows for displaying progress when archiving or unarchiving model graphs. Its functions may only be called during the archiving/unarchiving process.  <br>                               Because of the potentially large size of the archives, ARA does not use simple monolithic memory blocks as known from many companion APIs. Instead, it establishes a stream-like archive format so that copying large blocks of memory can be avoided. Plug-ins that create large archives should use any mean of data reduction that is appropriate to reduce the archive size. For example, they may implement gzip compression. Since it has good knowledge of the characteristics of the data, it can configure the compression algorithms so that optimal results are achieved. Consequently, there's no point for host to try to compress the data any further with generic algorithms.  <br>                               Hosts that support both 32 and 64 bit architectures shall be aware of the fact that ARA archive sizes are pointer-sized data types, so they will differ in bit width between these architectures. This must be taken into account when storing the archive size in the host's document structure. Also, when importing documents from 64 bit into 32 bit, the host must check whether the archive is small enough to be loaded at all (i.e. its size fits into 32 bits). If not, it shall refuse to load the archive and provide a proper error message. This may seem like a restriction, but the reasoning behind this is that if the archive already exceeds the available address space, the resulting unarchived graph will do so too.  <br>                               There's no creation or destruction call for the archive readers/writers because they are provided by the host for the duration of the (un-)archiving process, so the lifetime is implicitly defined.  <br>                               When using API generation 1 or older and loading an archive through the deprecated functions begin-/endRestoringDocumentFromArchive(), plug-ins may choose to access the associated archive reader upon either begin- or endRestoringDocumentFromArchive() or even upon both calls, as suitable for their implementation - hosts must be able to provide the requested data during the duration of both calls.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_archiving_controller_interface" title="Base class for implementing ARAArchivingControllerInterface.">ARA::Host::ArchivingControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_archiving_controller" title="Wrapper class for the ARAArchivingControllerInterface provided by the host.">ARA::PlugIn::HostArchivingController</a> </td></tr>
<tr id="row_5_2_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___host___model___content___access___controller.html" target="_self">Model Content Access Controller</a></td><td class="desc">This optional interface provides access to host model data such as the musical context. Its functions may only be called from ARADocumentControllerInterface.create...() or update...() for the object currently created/updated, or from <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">ARADocumentControllerInterface::endEditing()</a> for any object.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_content_access_controller_interface" title="Base class for implementing ARAContentAccessControllerInterface.">ARA::Host::ContentAccessControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_content_access_controller" title="Wrapper class for the ARAContentAccessControllerInterface by the host.">ARA::PlugIn::HostContentAccessController</a> </td></tr>
<tr id="row_5_3_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___host___model___update___controller___interface.html" target="_self">Model Update Controller Interface</a></td><td class="desc">This optional host interface allows the host to be notified about content changes in the plug-in. Its functions may only be called from <a class="el" href="group___plug-_in___document___controller.html#a0f37365379866cc1a596291f85fbcbe7" title="Tell the plug-in to send all pending update notifications for the given document. This must be called...">ARADocumentControllerInterface::notifyModelUpdates()</a>.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_model_update_controller_interface" title="Base class for implementing ARAModelUpdateControllerInterface.">ARA::Host::ModelUpdateControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_model_update_controller" title="Wrapper class for the ARAModelUpdateControllerInterface provided by the host.">ARA::PlugIn::HostModelUpdateController</a> </td></tr>
<tr id="row_5_4_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___host___playback___controller___interface.html" target="_self">Playback Controller Interface</a></td><td class="desc">This optional host interface allows the plug-in to request playback state changes. The functions in this interface may be called concurrently, but not from render-threads. The host may choose to ignore any of these requests. The requests will typically be scheduled and executed with some delay. The current state of playback is transmitted via the companion API.  <br>                               Host developer using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html#class_a_r_a_1_1_host_1_1_playback_controller_interface" title="Base class for implementing ARAPlaybackControllerInterface.">ARA::Host::PlaybackControllerInterface</a>. For plug-in developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html#class_a_r_a_1_1_plug_in_1_1_host_playback_controller" title="Wrapper class for the ARAPlaybackControllerInterface provided by the host.">ARA::PlugIn::HostPlaybackController</a> </td></tr>
<tr id="row_5_5_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___host___document___controller___instance.html" target="_self">Document Controller Instance</a></td><td class="desc">The callbacks into the host are published by the host when creating a document controller on the plug-in side to maintain an ARA model graph. The instance struct and all interfaces and host refs therein must remain valid until the document controller is destroyed. The host can choose to create its controller objects per document controller instance, or it can share a single instance between all document controllers, whatever fits its needs. It may even mix-and-match both approaches per individual interface </td></tr>
<tr id="row_6_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_6_" class="arrow" onclick="toggleFolder('6_')">&#9660;</span><a class="el" href="group___plug___in___interfaces.html" target="_self">Plug-In Interfaces</a></td><td class="desc"></td></tr>
<tr id="row_6_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___partial___document___persistency.html" target="_self">Partial Document Persistency</a></td><td class="desc"> <br>                               These optional filters allow to only store a subset of the document graph into an archive, or only restore a subset of an archive into the document graph </td></tr>
<tr id="row_6_1_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___processing___algorithm___selection.html" target="_self">Processing Algorithm Selection</a></td><td class="desc"></td></tr>
<tr id="row_6_2_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___plug-_in___document___controller.html" target="_self">Document Controller</a></td><td class="desc">ARA model objects are created and managed by the ARA Document Controller provided by the plug-in. The host uses the factory and management functions of the Document Controller to create a partial copy of its model translated into the ARA world. It is created using a factory which can be either retrieved by scanning the plug-in binaries for a dedicated factory or by requesting it from a living companion plug-in instance. The host is responsible for keeping the document controller alive as long as any objects created through it are still living (kind of implicit ref-counting). This means that its live time is independent of the companion plug-in instances - they may all be gone at some point but the ARA graph may still be accessed through its document controller. The host must also keep the document controller alive as long as any companion plug-in instance which it has bound to it is actively used. The actual destruction of the plug-in instance may be done later (to ease reference counting implementation), but rendering the plug-in, accessing its state or showing its UI is only valid as long as the ARA document controller it has been bound is still alive. Except for some rare, explicitly documented functions like getPlaybackRegionHeadAndTailTime(), the document controller interface must always be called from the same thread - usually hosts will manage their internal model as well as the attached ARA graph from the application's main thread, triggered from the main run loop. If a host decides to use a different thread for maintaining the ARA model, it may need to implement some sort of locking so that its updates on the ARA model thread do not interfere concurrently with the main run loop's event processing as it drives the plug-in's UI code and notification system.  <br>                               Plug-in developers using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_document_controller_interface" title="Base class for implementing ARADocumentControllerInterface.">ARA::PlugIn::DocumentControllerInterface</a>, or extend the already implemented <a class="el" href="group___a_r_a___library___a_r_a_plug___document___controller.html#class_a_r_a_1_1_plug_in_1_1_document_controller" title="Customizable default implementation of DocumentControllerInterface.">ARA::PlugIn::DocumentController</a> class as needed. For host developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interface___wrappers.html#class_a_r_a_1_1_host_1_1_document_controller" title="Wrapper class for the plug-in ARADocumentControllerInterface.">ARA::Host::DocumentController</a> </td></tr>
<tr id="row_6_3_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___plug-_in___document___controller___instance.html" target="_self">Document Controller Instance</a></td><td class="desc">The callbacks into the plug-in are published by the plug-in when the host requests the creation of a document controller via the factory. The instance struct and all interfaces and host refs therein must remain valid until the document controller is destroyed. The plug-in can choose to create its controller objects per document controller instance, or it can share a single instance between all document controllers, whatever fits its needs. It may even mix-and-match both approaches per individual interface </td></tr>
<tr id="row_6_4_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___plug-_in___factory.html" target="_self">Plug-In Factory</a></td><td class="desc">Static entry into ARA, allows to create ARA objects </td></tr>
<tr id="row_6_5_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_6_5_" class="arrow" onclick="toggleFolder('6_5_')">&#9660;</span><a class="el" href="group___plug-_in___extension.html" target="_self">Plug-In Extension</a></td><td class="desc">The plug-in extension provides ARA-specific additional functionality per companion plug-in instance. On a conceptual level, the plug-in extension is not an object of its own, but merely a set of additional interfaces of the companion plug-in instance, augmenting it with a few ARA-specific features in a fashion that is independent from the actual companion API in use. Accordingly, it is coupled 1:1 to the companion plug-in instance and its lifetime matches the lifetime of the companion plug-in instance (no separate destruction function needed). Along the same lines, plug-in extensions themselves are not persistent.  <br>                               The plug-in extension is exposed towards the host when it binds a plug-in instance as created by the companion APIs to a specific ARA model graph, represented by its associated document controller. This setup call is executed via a vendor-specific extension of the companion API and may only be made once. It shifts the "normal" companion plug-in into the ARA world, and once established, this coupling cannot be undone, it remains active until the plug-in instance is destroyed.  <br>                               Note that both performing the explicit binding and the implicit unbinding upon destruction will likely need to access plug-in internal data structures shared with with the document controller implementation. To avoid adding costly thread safety measures when maintaining this shared state, hosts should always perform these operations from the document controller thread (typically the main thread). This restriction may or may not apply when using the same companion API without ARA, so host developers might need to add extra precaution for the ARA case.  <br>                               When ARA is enabled, the renderer behavior has slightly different semantics compared to the non-ARA use case. Since ARA renderers are essentially generators that use non-realtime data to generate realtime signals, they do not use the realtime input signal for processing. Playback renderers will simply ignore their inputs, but editor renderers will always add their output signal to the input signal provided by the host. If a plug-in assumes both rendering roles, playback rendering will already ignore the inputs, so the editor rendering will directly add to the playback output, not to the input.  <br>                               Since ARA 2.0, the host can explicitly establish the roles that the given instance will assume in its specific implementation upon binding the plug-in instance to the ARA document controller. Each role is associated with a dedicated feature set that only is available when the particular role has been established. Depending on the chosen roles, the following calls control which playback regions are to be rendered according to which rule. Separating roles allows for more flexible ARA integrations and optimizes resource usage. A host could for example use a playback renderer plug-in instance playback region, plus one plug-in instance per track for editor rendering and viewing all regions on that track. Amongst other behavior, the roles heavily affect the relationship between plug-in instances and playback regions. For rendering, each plug-in extension can handle multiple playback regions if desired, albeit the semantics for modifying the set of associated regions per renderer are somewhat different between playback and editor renderers, see below. For editor view purposes, the relationship is not explicit to accommodate for a very broad range of user interface concepts that need to interact with the API. Generally, each editor view is associated with all playback regions in the document controller to which the plug-in is bound. However, typically only a varying subset of those regions will be shown at any point in time, depending on the intrinsic feature set of the plug-in, and reflecting the selection that the user has performed in the host - see notifySelection() </td></tr>
<tr id="row_6_5_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___playback___renderer___interface.html" target="_self">Playback Renderer Interface (Added In ARA 2.0)</a></td><td class="desc">See <a class="el" href="group___plug-_in___extension.html#ggadb888a1dc7f658281705411c7b4c253ea5f7f13e0744f8a3b1a0167aef4cc91ca" title="Role: playback render. Plug-in instances fulfilling this role are performing playback rendering,...">kARAPlaybackRendererRole</a>.  <br>                               Plug-in developers using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_playback_renderer_interface" title="Base class for implementing ARAPlaybackRendererInterface.">ARA::PlugIn::PlaybackRendererInterface</a>, or extend the already implemented <a class="el" href="group___a_r_a___library___a_r_a_plug___plug_in_instance_roles.html#class_a_r_a_1_1_plug_in_1_1_playback_renderer" title="Extensible plug-in instance role class implementing an ARA Playback Renderer Interface (Added In ARA ...">ARA::PlugIn::PlaybackRenderer</a> class as needed. For host developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interface___wrappers.html#class_a_r_a_1_1_host_1_1_playback_renderer" title="Wrapper class for the ARAPlaybackRendererInterface provided by the plug-in.">ARA::Host::PlaybackRenderer</a> </td></tr>
<tr id="row_6_5_1_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___editor___renderer___interface.html" target="_self">Editor Renderer Interface (Added In ARA 2.0)</a></td><td class="desc">See <a class="el" href="group___plug-_in___extension.html#ggadb888a1dc7f658281705411c7b4c253ea43bac0cdb9433838cab4b79734aa4486" title="Role: editor render. Plug-in instances fulfilling this role are performing auxiliary realtime renderi...">kARAEditorRendererRole</a>.  <br>                               Plug-in developers using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_editor_renderer_interface" title="Base class for implementing ARAEditorRendererInterface.">ARA::PlugIn::EditorRendererInterface</a>, or extend the already implemented <a class="el" href="group___a_r_a___library___a_r_a_plug___plug_in_instance_roles.html#class_a_r_a_1_1_plug_in_1_1_editor_renderer" title="Extensible plug-in instance role class implementing an ARA Editor Renderer Interface (Added In ARA 2....">ARA::PlugIn::EditorRenderer</a> class as needed. For host developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interface___wrappers.html#class_a_r_a_1_1_host_1_1_editor_renderer" title="Wrapper class for the ARAEditorRendererInterface provided by the plug-in.">ARA::Host::EditorRenderer</a> </td></tr>
<tr id="row_6_5_2_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___editor___view___interface.html" target="_self">Editor View Interface (Added In ARA 2.0)</a></td><td class="desc">See <a class="el" href="group___plug-_in___extension.html#ggadb888a1dc7f658281705411c7b4c253eac033ffe4d4ae6821fe05a418929cf093" title="Role: editor view. Plug-in instances fulfilling this role can be used to display a GUI....">kARAEditorViewRole</a>.  <br>                               Users will often reconfigure the plug-in view through scrolling, zooming, navigating lists of entities, etc. to select the subset of ARA entities that they currently need to view or edit. Those selection features can be implemented in the plug-in (which was the only available solution in ARA 1). However, the host applications already have established user workflows for selecting their representations of the ARA objects. Making those workflows available to the plug-ins is leads to a much more consistent, streamlined user experience. Since the views are implemented through the companion API, there is no matching ARA entity yet. Instead, the companion plug-in instance is used as a controller for its associated view. (Note that while some companion APIs allow for multiple views of a given plug-in used at the same time, this is not recommended when using ARA editor views.) These calls only affect views, not the audio rendering. They only should be made while the plug-in is showing its UI, or before entering this state (i.e. during GUI setup phase), in order to optimize resource usage. Accordingly, the host should send an update of the selection when (re-)opening an ARA plug-in view. These calls also may be made while changes are being made to the model graph (i.e. inside of pairs of <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">ARADocumentControllerInterface::beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">ARADocumentControllerInterface::endEditing()</a>).  <br>                               Plug-in developers using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_editor_view_interface" title="Base class for implementing ARAEditorViewInterface.">ARA::PlugIn::EditorViewInterface</a>, or extend the already implemented <a class="el" href="group___a_r_a___library___a_r_a_plug___plug_in_instance_roles.html#class_a_r_a_1_1_plug_in_1_1_editor_view" title="Extensible plug-in instance role class implementing an ARA Editor View Interface (Added In ARA 2....">ARA::PlugIn::EditorView</a> class as needed. For host developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interface___wrappers.html#class_a_r_a_1_1_host_1_1_editor_view" title="Wrapper class for the ARAEditorViewInterface provided by the plug-in.">ARA::Host::EditorView</a> </td></tr>
<tr id="row_6_5_3_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___plug-_in___extension___interface.html" target="_self">Deprecated: Plug-In Extension Interface.</a></td><td class="desc">This interface was used before ARA 2.0 defined dedicated plug-in roles. It is only to be implemented when ARA 1 backwards compatibility is desired. An ARA 1 call to set/removePlaybackRegion() in this interface is equivalent to calling both set/removePlaybackRegion() in <a class="el" href="group___playback___renderer___interface.html#struct_a_r_a_playback_renderer_interface" title="Plug-in interface: playback renderer. The function pointers in this struct must remain valid until th...">ARAPlaybackRendererInterface</a> and add/removePlaybackRegion() in <a class="el" href="group___editor___renderer___interface.html#struct_a_r_a_editor_renderer_interface" title="Plug-in interface: editor renderer. The function pointers in this struct must remain valid until the ...">ARAEditorRendererInterface</a>. To some extend ARA 1 also uses this to for tasks now associated with <a class="el" href="group___editor___view___interface.html#struct_a_r_a_editor_view_interface" title="Plug-in interface: view controller. The function pointers in this struct must remain valid until the ...">ARAEditorViewInterface</a>: opening the UI of an ARA 1 plug-in instance is interpreted as selection of the playback region set via this interface </td></tr>
<tr id="row_7_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a_audio_file_chunks.html" target="_self">ARA Audio File Chunks</a></td><td class="desc">To allow for distributing persistent ARA audio source state information together with the underlying audio file in a way that is transparent to the plug-ins and can be supported by all hosts, ARA 2.0 defines a format for embedding such states into standardized audio file chunks. From there, they can be imported into any ARA document using <a class="el" href="group___partial___document___persistency.html">Partial Document Persistency</a>.  <br>                               The most obvious use case for this is that it enables audio content providers to ship audio files with properly validated, ready-to-use audio source analysis for multiple plug-ins (or incompatible versions of a plug-in if needed). For example, this allows for loading polyphonic audio loops into Melodyne without time-consuming analysis and very quickly adjusting them to follow the song key and chord progression, making the published audio material much more versatile to use in various productions. Other scenarios where such file chunks are used include exporting data from one plug-in to another, or adding ARA objects to a host document via dragging and dropping audio files from a plug-in that either generates these files on the fly (e.g. export of layers in SpectraLayers) or copies them from a built-in sound library.  <br>                               The ARA chunk should be evaluated by the host both when adding a new audio file to the arrangement and when applying a new/different ARA plug-in for a region/file already used in the arrangement. Note that after loading the data, ARA content readers can be used to extract more information about the audio source - such as tempo map, time and key signatures, etc.  <br>                               Plug-in vendors shall optimize the encoding of the audio source state information for audio file chunks according to very different criteria compared to encoding the same state for regular ARA song document archives: The audio file states are going to be widely distributed and will be used over a long period of time in very different contexts, whereas song documents are typically only used on a single machine for a rather short time. Audio file archives therefore should emphasize small data size over en-/decoding speed - encoding is only done once, and decoding only happens for a single audio source at a time (compared to hundreds of audio sources in a typical song archive). Even more important, audio file archives are likely going to be used across a wide range of products versions and shall be stable across a long time. The encoding should therefore be as much backwards compatible as possible, potentially even using different encoding based on the current state of the audio source: if e.g. a particular non-backwards compatible feature of the plug-in is not used in the given state, the plug-in can choose an older format to store the data than if that particular feature was utilized. For these reasons, audio file chunks will typically not use the <a class="el" href="group___plug-_in___factory.html#adebff6774723eb0490324afdcb2a993d" title="Identifier for document archives created by the document controller. This ID must be globally unique ...">ARAFactory::documentArchiveID</a> but instead one of the IDs listed in <a class="el" href="group___plug-_in___factory.html#ad086f2eb62f7a90a0ea6fa22f5ea6f78" title="Variable-sized C array listing other identifiers of archives that the document controller can import....">ARAFactory::compatibleDocumentArchiveIDs</a>.  <br>                               Creating audio file chunks may not be meaningful nor supported for any given plug-in. If for example the plug-in does not perform any costly analysis and has no relevant editable audio source state, there is no reason to create audio file chunks for it. Therefore, creating such chunks is currently done only through dedicated authoring tools (such as Melodyne's standalone version) and not directly available in ARA host applications.  <br>                               Covering both AIFF and WAVE formats, ARA stores its data by extending iXML chunks as specified here: <a href="http://www.ixml.info">http://www.ixml.info</a> Inside the iXML document, there's a custom tag &lt;ARA&gt; that encloses a dictionary of audio source archives, encoded as array tagged &lt;audioSources&gt;. Each entry in the array is intended for a different plug-in (or incompatible version fo a plug-in) and contains the tag &lt;documentArchiveID&gt; which also functions as the key for the dictionary, and associated data which includes the actual binary archive and meta information, for example: </td></tr>
<tr id="row_8_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_8_" class="arrow" onclick="toggleFolder('8_')">&#9660;</span><a class="el" href="group___companion___a_p_is.html" target="_self">Companion APIs</a></td><td class="desc"></td></tr>
<tr id="row_8_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___audio___unit.html" target="_self">Audio Unit</a></td><td class="desc">ARA support for Audio Units is mostly based on private Audio Unit properties. The input/output pattern for the associated property data structs is similar to struct AudioUnitParameterStringFromValue in the Audio Unit API. To be able to detect potential collisions if some host or Audio Unit uses the same private property for non-ARA communication, the actual ARA data is embedded into a property data struct that also contains an ARA magic number. For this magic number to work properly for all host/plug-in combinations, it's crucial that hosts set it on input and check it after output, and that plug-ins check it before writing to the property struct </td></tr>
<tr id="row_8_1_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___audio___unit__v3.html" target="_self">Audio Unit V3</a></td><td class="desc">Experimental support for Audio Unit v3 (App Extension) </td></tr>
<tr id="row_8_2_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___v_s_t3.html" target="_self">VST3</a></td><td class="desc"></td></tr>
<tr id="row_9_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_9_" class="arrow" onclick="toggleFolder('9_')">&#9660;</span><a class="el" href="group___a_r_a___library.html" target="_self">ARA C++ Library</a></td><td class="desc"></td></tr>
<tr id="row_9_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_9_0_" class="arrow" onclick="toggleFolder('9_0_')">&#9660;</span><a class="el" href="group___a_r_a___library___utilities.html" target="_self">Utility Classes and Functions</a></td><td class="desc">Utilities designed to make communicating across the API boundary between host and plug-in more convenient </td></tr>
<tr id="row_9_0_0_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___utility___sized_structs.html" target="_self">Versioned Sized Structs</a></td><td class="desc">Classes used to managed versioned ARA structs by their <code>structSize</code> member </td></tr>
<tr id="row_9_0_1_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___utility___content___readers.html" target="_self">Reading Content</a></td><td class="desc">Classes designed to make content reading more convenient </td></tr>
<tr id="row_9_0_2_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___utility___content___update___scopes.html" target="_self">Content Update Scopes</a></td><td class="desc">Utility class for defining the scope of a content update </td></tr>
<tr id="row_9_0_3_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___utility___pitch___interpretation.html" target="_self">Interpreting Pitch, Chords, and Key Signatures</a></td><td class="desc">Classes designed to parse and interpret <a class="el" href="group___model___tuning___key___signatures__and___chords.html#struct_a_r_a_content_chord" title="Content reader event class: chords provided by kARAContentTypeSheetChords. The event position relates...">ARAContentChord</a> / <a class="el" href="group___model___tuning___key___signatures__and___chords.html#struct_a_r_a_content_key_signature" title="Content reader event class: key signature provided by kARAContentTypeKeySignatures....">ARAContentKeySignature</a> data </td></tr>
<tr id="row_9_0_4_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___utility___timeline___conversion.html" target="_self">Musical Timeline Conversions</a></td><td class="desc">Classes designed to perform conversions between musical and linear timelines </td></tr>
<tr id="row_9_0_5_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___utility___channel___arrangement.html" target="_self">Surround Channel Arrangement</a></td><td class="desc">Utility class dealing with the Companion-API-dependent surround channel arrangements </td></tr>
<tr id="row_9_0_6_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___utility___rounding.html" target="_self">Rounding Utility Functions</a></td><td class="desc">Rounding utility functions used in the ARA SDK </td></tr>
<tr id="row_9_0_7_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___utility___std_vec.html" target="_self">std::vector Utility Functions</a></td><td class="desc"><code>std::vector</code> related utility functions used in the ARA SDK </td></tr>
<tr id="row_9_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_9_1_" class="arrow" onclick="toggleFolder('9_1_')">&#9660;</span><a class="el" href="group___a_r_a___library___host___dispatch.html" target="_self">Host Dispatch</a></td><td class="desc">Classes and interfaces designed to ease ARA hosting implementations.  <br>                               Requires linking <code>ARAHostDispatch.cpp</code> with your binary </td></tr>
<tr id="row_9_1_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___host___dispatch___host___interfaces.html" target="_self">Host Interfaces</a></td><td class="desc">Interfaces to be implemented by ARA hosts </td></tr>
<tr id="row_9_1_1_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interface___wrappers.html" target="_self">Plug-In Interface Wrappers</a></td><td class="desc">Wrappers for the interfaces used to communicate with and control ARA plug-ins </td></tr>
<tr id="row_9_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_9_2_" class="arrow" onclick="toggleFolder('9_2_')">&#9660;</span><a class="el" href="group___a_r_a___library___plug_in___dispatch.html" target="_self">Plug-In Dispatch</a></td><td class="desc">Classes and interfaces designed to ease ARA plug-in implementations.  <br>                               Requires linking <code>ARAPlugInDispatch.cpp</code> with your binary </td></tr>
<tr id="row_9_2_0_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html" target="_self">Plug-In Interfaces</a></td><td class="desc">Interfaces to be implemented by ARA plug-ins </td></tr>
<tr id="row_9_2_1_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___host___dispatch___host___interface___wrappers.html" target="_self">Host Interface Wrappers</a></td><td class="desc">Wrappers for the interfaces used to communicate with and control the ARA host </td></tr>
<tr id="row_9_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_9_3_" class="arrow" onclick="toggleFolder('9_3_')">&#9660;</span><a class="el" href="group___a_r_a___library___a_r_a_plug.html" target="_self">ARAPlug</a></td><td class="desc">Fully implemented interfaces from ARA <a class="el" href="group___a_r_a___library___plug_in___dispatch.html">Plug-In Dispatch</a>.  <br>                               Requires linking <code>ARAPlugInDispatch.cpp</code> and <code>ARAPlug.cpp</code> with your binary </td></tr>
<tr id="row_9_3_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___a_r_a_plug___utility___classes.html" target="_self">Utility Classes</a></td><td class="desc">Classes that plug-in developers can use to make ARA operations and host communication easier </td></tr>
<tr id="row_9_3_1_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___a_r_a_plug___model___objects.html" target="_self">Model Objects</a></td><td class="desc">C++ classes representing the <a class="el" href="group___a_r_a___model___graph.html">ARA Model Graph</a> objects </td></tr>
<tr id="row_9_3_2_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___a_r_a_plug___document___controller.html" target="_self">Document Controller</a></td><td class="desc">Customizable default implementation of <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_document_controller_interface" title="Base class for implementing ARADocumentControllerInterface.">DocumentControllerInterface</a>. </td></tr>
<tr id="row_9_3_3_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___a_r_a_plug___plug_in_instance_roles.html" target="_self">Plug-In Instance Roles</a></td><td class="desc">Classes that implement the ARA plug-in extension instance role interfaces </td></tr>
<tr id="row_9_3_4_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___a_r_a_plug___plug_in_entry.html" target="_self">Plug-In Entry</a></td><td class="desc">Classes that implement the entry into the ARA plug-in </td></tr>
<tr id="row_9_4_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group___a_r_a___library___i_p_c.html" target="_self">ARA IPC</a></td><td class="desc">Proxies for both host and plug-in side implementations of ARA IPC </td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
