<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARA SDK 2.1.0: Document Controller</title>
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="shortcut icon" sizes="16x16" href="./favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="DoxygenStyleSheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ARA_Logo.png" height="50px"/></td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___plug-_in___document___controller.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Document Controller<div class="ingroups"><a class="el" href="group___plug___in___interfaces.html">Plug-In Interfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>ARA model objects are created and managed by the ARA Document Controller provided by the plug-in. The host uses the factory and management functions of the Document Controller to create a partial copy of its model translated into the ARA world. It is created using a factory which can be either retrieved by scanning the plug-in binaries for a dedicated factory or by requesting it from a living companion plug-in instance. The host is responsible for keeping the document controller alive as long as any objects created through it are still living (kind of implicit ref-counting). This means that its live time is independent of the companion plug-in instances - they may all be gone at some point but the ARA graph may still be accessed through its document controller. The host must also keep the document controller alive as long as any companion plug-in instance which it has bound to it is actively used. The actual destruction of the plug-in instance may be done later (to ease reference counting implementation), but rendering the plug-in, accessing its state or showing its UI is only valid as long as the ARA document controller it has been bound is still alive. Except for some rare, explicitly documented functions like getPlaybackRegionHeadAndTailTime(), the document controller interface must always be called from the same thread - usually hosts will manage their internal model as well as the attached ARA graph from the application's main thread, triggered from the main run loop. If a host decides to use a different thread for maintaining the ARA model, it may need to implement some sort of locking so that its updates on the ARA model thread do not interfere concurrently with the main run loop's event processing as it drives the plug-in's UI code and notification system.  <br>                               Plug-in developers using C++ ARA Library can implement the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interfaces.html#class_a_r_a_1_1_plug_in_1_1_document_controller_interface" title="Base class for implementing ARADocumentControllerInterface.">ARA::PlugIn::DocumentControllerInterface</a>, or extend the already implemented <a class="el" href="group___a_r_a___library___a_r_a_plug___document___controller.html#class_a_r_a_1_1_plug_in_1_1_document_controller" title="Customizable default implementation of DocumentControllerInterface.">ARA::PlugIn::DocumentController</a> class as needed. For host developers this interface is wrapped by the <a class="el" href="group___a_r_a___library___host___dispatch___plug-_in___interface___wrappers.html#class_a_r_a_1_1_host_1_1_document_controller" title="Wrapper class for the plug-in ARADocumentControllerInterface.">ARA::Host::DocumentController</a>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:struct_a_r_a_document_controller_interface"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#struct_a_r_a_document_controller_interface">ARADocumentControllerInterface</a></td></tr>
<tr class="memdesc:struct_a_r_a_document_controller_interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plug-in interface: document controller. The function pointers in this struct must remain valid until the document controller is destroyed by the host.  <a href="group___plug-_in___document___controller.html#struct_a_r_a_document_controller_interface">More...</a><br /></td></tr>
<tr class="separator:struct_a_r_a_document_controller_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8bff5d917f3cbcaf9febb7d5945ecb7d"><td class="memItemLeft" align="right" valign="top"><a id="ga8bff5d917f3cbcaf9febb7d5945ecb7d"></a>
typedef struct ARADocumentControllerRefMarkupType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a></td></tr>
<tr class="memdesc:ga8bff5d917f3cbcaf9febb7d5945ecb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the plug-in side representation of a document controller (opaque to the host). <br /></td></tr>
<tr class="separator:ga8bff5d917f3cbcaf9febb7d5945ecb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_a_r_a_document_controller_interface" id="struct_a_r_a_document_controller_interface"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_a_r_a_document_controller_interface">&#9670;&nbsp;</a></span>ARADocumentControllerInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ARADocumentControllerInterface</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Plug-in interface: document controller. The function pointers in this struct must remain valid until the document controller is destroyed by the host. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Size-based struct versioning</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8272db3aa4580fe6b7beb9697d0787b7"></a> See <a class="el" href="group___versioned__structs.html">Versioned structs</a>. </p>
</td></tr>
<tr class="memitem:a0f46213b5aa9ed379dd33063819e9833"><td class="memItemLeft" align="right" valign="top"><a id="a0f46213b5aa9ed379dd33063819e9833"></a>
<a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>structSize</b></td></tr>
<tr class="separator:a0f46213b5aa9ed379dd33063819e9833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Destruction</h3></td></tr>
<tr class="memitem:a867fcd0161daa52f186aaa34c0c22bf7"><td class="memItemLeft" align="right" valign="top"><a id="a867fcd0161daa52f186aaa34c0c22bf7"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a867fcd0161daa52f186aaa34c0c22bf7">destroyDocumentController</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef)</td></tr>
<tr class="memdesc:a867fcd0161daa52f186aaa34c0c22bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the controller and its associated document. The host must delete all objects associated with the document graph (audio sources, musical contexts etc.) before making this call. Note that the objects exported via the <a class="el" href="group___plug-_in___extension.html#struct_a_r_a_plug_in_extension_instance" title="The plug-in extension instance struct and all interfaces and refs therein must remain valid until the...">ARAPlugInExtensionInstance</a> are not considered part of the document graph, their destruction may happen before or after destroying the document controller that they are bound to. <br /></td></tr>
<tr class="separator:a867fcd0161daa52f186aaa34c0c22bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Link back to the factory</h3></td></tr>
<tr class="memitem:a792202b3ee87c028ea704752f36abb19"><td class="memItemLeft" align="right" valign="top"><a id="a792202b3ee87c028ea704752f36abb19"></a>
const <a class="el" href="group___plug-_in___factory.html#struct_a_r_a_factory">ARAFactory</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a792202b3ee87c028ea704752f36abb19">getFactory</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef)</td></tr>
<tr class="memdesc:a792202b3ee87c028ea704752f36abb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the static ARA factory that was used to create this controller. This provides a convenient traversal to the name of the plug-in, the description of its capabilities, its archive IDs etc. <br /></td></tr>
<tr class="separator:a792202b3ee87c028ea704752f36abb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Update management</h3></td></tr>
<tr class="memitem:a73d999e8600d4b9576c3b18fe8dce16f"><td class="memItemLeft" align="right" valign="top"><a id="a73d999e8600d4b9576c3b18fe8dce16f"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f">beginEditing</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef)</td></tr>
<tr class="memdesc:a73d999e8600d4b9576c3b18fe8dce16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an editing session on a document. An editing session can contain an arbitrary set of modifications that belong together. Since many model edits can result in rather expensive updates on the plug-in side, this call allows for grouping the edits and postponing the updates until the new model state is final, which potentially saves some intermediate updates. <br /></td></tr>
<tr class="separator:a73d999e8600d4b9576c3b18fe8dce16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4946909515472d8ea4f5f1ee5cac599"><td class="memItemLeft" align="right" valign="top"><a id="ab4946909515472d8ea4f5f1ee5cac599"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599">endEditing</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef)</td></tr>
<tr class="memdesc:ab4946909515472d8ea4f5f1ee5cac599"><td class="mdescLeft">&#160;</td><td class="mdescRight">End an editing session on a document. Note that when receiving this call, the plug-in will update any amount of internal state. These edits may lead to update notifications to the host, and the host may in turn read affected content from the plug-in and update its own model accordingly. One example for this the way that Melodyne maintains chords and scales associated with audio modifications. It copies this data from the musical context into the audio modifications, so that when editing regions the notes appear in the proper pitch grid. If moving playback regions in the song, these copies may need to be updated, and Melodyne will report the resulting audio modification content changes to the host. To ensure that any such follow-up updates are added to the same undo cycle, hosts that actively read plug-in content data should immediately (i.e. within the same undo frame) call <a class="el" href="group___plug-_in___document___controller.html#a0f37365379866cc1a596291f85fbcbe7" title="Tell the plug-in to send all pending update notifications for the given document. This must be called...">notifyModelUpdates()</a> after making this call. <br /></td></tr>
<tr class="separator:ab4946909515472d8ea4f5f1ee5cac599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f37365379866cc1a596291f85fbcbe7"><td class="memItemLeft" align="right" valign="top"><a id="a0f37365379866cc1a596291f85fbcbe7"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a0f37365379866cc1a596291f85fbcbe7">notifyModelUpdates</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef)</td></tr>
<tr class="memdesc:a0f37365379866cc1a596291f85fbcbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the plug-in to send all pending update notifications for the given document. This must be called periodically by the host whenever not editing nor restoring the document. Only when processing this call, the plug-in may call back into the host using <a class="el" href="group___host___model___update___controller___interface.html#struct_a_r_a_model_update_controller_interface" title="Host interface: model update controller. As with all host interfaces, the function pointers in this s...">ARAModelUpdateControllerInterface</a>. Hosts must be aware after receiving <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a>, plug-ins may choose to postpone any subset of their internal state updates until the matching call to <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. This means that if the host for some reason needs to wait for a specific update in the plug-in to occur (such as waiting for an analysis to finish) it must do so outside of pairs of <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. <br /></td></tr>
<tr class="separator:a0f37365379866cc1a596291f85fbcbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Document Persistency (extended in ARA 2.0)</h3></td></tr>
<tr class="memitem:a89af92729a2f3e7027c674f5522dc258"><td class="memItemLeft" align="right" valign="top"><a id="a89af92729a2f3e7027c674f5522dc258"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a89af92729a2f3e7027c674f5522dc258">beginRestoringDocumentFromArchive</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___host___archiving___controller.html#ga05025b209d04967af019d599e4cf5838">ARAArchiveReaderHostRef</a> archiveReaderHostRef)</td></tr>
<tr class="memdesc:a89af92729a2f3e7027c674f5522dc258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin an unarchiving session of the document and its associated objects. <br  />
<b>Deprecated</b> <br  />
 Since version 2_0_Final this call has been superseded by the combination of <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#a6ad2b9f4070e12178057c3c9590f4c32" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">restoreObjectsFromArchive()</a>. This allows for optional filtering, but also simplifies both host and plug-in implementation. <br /></td></tr>
<tr class="separator:a89af92729a2f3e7027c674f5522dc258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363873f0f7d49e2f94b814d93bd30a0d"><td class="memItemLeft" align="right" valign="top"><a id="a363873f0f7d49e2f94b814d93bd30a0d"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a363873f0f7d49e2f94b814d93bd30a0d">endRestoringDocumentFromArchive</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___host___archiving___controller.html#ga05025b209d04967af019d599e4cf5838">ARAArchiveReaderHostRef</a> archiveReaderHostRef)</td></tr>
<tr class="memdesc:a363873f0f7d49e2f94b814d93bd30a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">End an unarchiving session of the document and its associated objects. <br  />
<b>Deprecated</b> <br  />
 Since version 2_0_Final this call has been superseded by the combination of <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#a6ad2b9f4070e12178057c3c9590f4c32" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">restoreObjectsFromArchive()</a>. This allows for optional filtering, but also simplifies both host and plug-in implementation.  <br>                               When using API generation 1 or older and using this call, the host must pass the same archiveReaderHostRef as used for <a class="el" href="group___plug-_in___document___controller.html#a89af92729a2f3e7027c674f5522dc258" title="Begin an unarchiving session of the document and its associated objects.  Deprecated   Since version ...">beginRestoringDocumentFromArchive()</a>. This way, plug-ins can choose to evaluate the archive upon beginRestoring() or endRestoring(), or even upon both calls if needed. <br /></td></tr>
<tr class="separator:a363873f0f7d49e2f94b814d93bd30a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54adacf3de39b63113da80454f8257b"><td class="memItemLeft" align="right" valign="top"><a id="ae54adacf3de39b63113da80454f8257b"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#ae54adacf3de39b63113da80454f8257b">storeDocumentToArchive</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___host___archiving___controller.html#gac673356af66f264ace3fb7c694e22c86">ARAArchiveWriterHostRef</a> archiveWriterHostRef)</td></tr>
<tr class="memdesc:ae54adacf3de39b63113da80454f8257b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an archive of the internal state of a given document and all its associated objects. <br  />
<b>Deprecated</b> <br  />
 Since version 2_0_Final this call has been superseded by <a class="el" href="group___plug-_in___document___controller.html#abcea77fa97661a896a5144b2ff3e140e" title="Create a partial archive of the internal state of the specified objects. Archives may only be created...">storeObjectsToArchive()</a>, which allows for optional filtering, but is otherwise identical. <br /></td></tr>
<tr class="separator:ae54adacf3de39b63113da80454f8257b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad2b9f4070e12178057c3c9590f4c32"><td class="memItemLeft" align="right" valign="top"><a id="a6ad2b9f4070e12178057c3c9590f4c32"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a6ad2b9f4070e12178057c3c9590f4c32">restoreObjectsFromArchive</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___host___archiving___controller.html#ga05025b209d04967af019d599e4cf5838">ARAArchiveReaderHostRef</a> archiveReaderHostRef, const <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_restore_objects_filter">ARARestoreObjectsFilter</a> *filter)</td></tr>
<tr class="memdesc:a6ad2b9f4070e12178057c3c9590f4c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unarchive the internal state of the specified objects. This call can be used both for unarchiving entire documents and for importing arbitrary objects into an existing document. An unarchiving session is conceptually identical to an editing session: after starting the session, the host rebuilds the graph using the regular object creation calls, then makes this call to let the plug-in parse the archive and inject the archived internal state into the graph as indicated by the persistentIDs of the relevant objects. Similarly, when importing objects, the host will perform an editing session and either create new objects or re-use existing objects (potentially adjusting their persistentID), then make this call to inject the imported state.  <br>                               The optional filter allows for restoring only a subset of the archived states into the graph. It can be NULL, in which case all archived states with matching persistentIDs will be restored. In that case, the call sequence <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a>, <a class="el" href="group___plug-_in___document___controller.html#a6ad2b9f4070e12178057c3c9590f4c32" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">restoreObjectsFromArchive()</a>, <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> is equivalent to the deprecated begin-/endRestoringDocumentFromArchive() for ARA 1, which has been superseded by this call. The host is not required to restore all objects in the archive. Any archived states that are either filtered explicitly, or for which there is no object with a matching persistent ID in the current graph are simply ignored. Since persistent IDs are only required to be unique per document (and not globally), hosts may encounter persistent ID conflicts when importing data from other documents. The optional <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_restore_objects_filter" title="Optional filter when restoring objects.  &lt;br&gt;                               \newline                 ...">ARARestoreObjectsFilter</a> provided for this call therefore allows to map between the IDs used in the archive and those used in the current graph if needed.  <br>                               The host can make multiple calls to <a class="el" href="group___plug-_in___document___controller.html#a6ad2b9f4070e12178057c3c9590f4c32" title="Unarchive the internal state of the specified objects. This call can be used both for unarchiving ent...">restoreObjectsFromArchive()</a> within the same editing session to import objects from multiple archives in one operation. It may even decide to implement its persistency based on partial archives entirely, using several calls to <a class="el" href="group___plug-_in___document___controller.html#abcea77fa97661a896a5144b2ff3e140e" title="Create a partial archive of the internal state of the specified objects. Archives may only be created...">storeObjectsToArchive()</a> with varying filters to split the document into slices appropriate to its implementation, see <a class="el" href="group___partial___document___persistency.html#a24ecfb6be6f94eed4038ea9d6ac202ea" title="Flag to indicate whether the plug-in should include its private, opaque document state in the archive...">ARAStoreObjectsFilter::documentData</a>.  <br>                               Result is kARAFalse if the access to the archive reader failed while trying to read the archive, or if decoding the data failed, kARATrue otherwise. Potential reason for failure include data corruption due to storage hardware failures, or broken dependencies when restoring partial archives as discussed above. The plug-in should try to recover as much state as possible in all cases, and the host should notify the user of such errors. If a failure happened already while reading the archive, the host is aware of this and can augment its error message to the user accordingly. If the failure happens inside the plug-in when decoding the data, the plug-in is responsible for guiding the user as good as possible, e.g. by listing or marking the affected objects. Note that since versioning is expressed through the ARA factory, the host must deal with potential versioning conflicts before making this call, and provide proper UI too. <br /></td></tr>
<tr class="separator:a6ad2b9f4070e12178057c3c9590f4c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcea77fa97661a896a5144b2ff3e140e"><td class="memItemLeft" align="right" valign="top"><a id="abcea77fa97661a896a5144b2ff3e140e"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#abcea77fa97661a896a5144b2ff3e140e">storeObjectsToArchive</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___host___archiving___controller.html#gac673356af66f264ace3fb7c694e22c86">ARAArchiveWriterHostRef</a> archiveWriterHostRef, const <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_store_objects_filter">ARAStoreObjectsFilter</a> *filter)</td></tr>
<tr class="memdesc:abcea77fa97661a896a5144b2ff3e140e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial archive of the internal state of the specified objects. Archives may only be created from documents that are not being currently edited. The optional filter allows for storing only a subset of the document graph into the archive. It can be NULL, in which case all objects in the graph will be stored. In that case, the call is equivalent to the deprecated <a class="el" href="group___plug-_in___document___controller.html#ae54adacf3de39b63113da80454f8257b" title="Create an archive of the internal state of a given document and all its associated objects....">storeDocumentToArchive()</a>, which has been superseded by this call. Result is kARAFalse if the access to the archive writer failed while trying to write the archive, kARATrue otherwise. The host is responsible for alerting the user about archive write errors, see <a class="el" href="group___host___archiving___controller.html#a39ccce1c9ea18b0303e5633c8b0ddefd" title="Write bytes. This may only be called from storeObjectsToArchive() or the deprecated storeDocumentToAr...">ARAArchivingControllerInterface::writeBytesToArchive()</a>. Note that for creating ARA audio file chunk archives, <a class="el" href="group___plug-_in___document___controller.html#a4759249602a579d2d561745eaa92182a" title="Create an archive of the internal state of the specified audio source suitable to be embedded into th...">storeAudioSourceToAudioFileChunk()</a> must be used instead, so that the plug-in can pick the correct encoding and return the corresponding (compatible) document archive ID. <br /></td></tr>
<tr class="separator:abcea77fa97661a896a5144b2ff3e140e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4759249602a579d2d561745eaa92182a"><td class="memItemLeft" align="right" valign="top"><a id="a4759249602a579d2d561745eaa92182a"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a4759249602a579d2d561745eaa92182a">storeAudioSourceToAudioFileChunk</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___host___archiving___controller.html#gac673356af66f264ace3fb7c694e22c86">ARAArchiveWriterHostRef</a> archiveWriterHostRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___object___references.html#ga4debd59b541464cf35ccfd48ed8d6e68">ARAPersistentID</a> *documentArchiveID, <a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a> *openAutomatically)</td></tr>
<tr class="memdesc:a4759249602a579d2d561745eaa92182a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an archive of the internal state of the specified audio source suitable to be embedded into the underlying audio file as ARA audio file chunks, see <a class="el" href="group___a_r_a_audio_file_chunks.html">ARA Audio File Chunks</a>. Hosts must check <a class="el" href="group___plug-_in___factory.html#a109051a3e886c9522ea4dd03ffc34fc3" title="Flag whether the plug-in supports exporting ARA audio file chunks via ARADocumentControllerInterface:...">ARAFactory::supportsStoringAudioFileChunks</a> before enabling users to store audio file chunks for the given plug-in. Archives may only be created from documents that are not being currently edited.  <br>                               This call differs from using <a class="el" href="group___plug-_in___document___controller.html#abcea77fa97661a896a5144b2ff3e140e" title="Create a partial archive of the internal state of the specified objects. Archives may only be created...">storeObjectsToArchive()</a> with an <a class="el" href="group___partial___document___persistency.html#struct_a_r_a_store_objects_filter" title="Optional filter when storing objects.  &lt;br&gt;                               \newline                   ...">ARAStoreObjectsFilter</a> in that the plug-in may choose a different internal encoding more suitable for this use case, indicated by returning a <code>documentArchiveID</code> that is likely one of the <a class="el" href="group___plug-_in___factory.html#ad086f2eb62f7a90a0ea6fa22f5ea6f78" title="Variable-sized C array listing other identifiers of archives that the document controller can import....">ARAFactory::compatibleDocumentArchiveIDs</a> rather than the <a class="el" href="group___plug-_in___factory.html#adebff6774723eb0490324afdcb2a993d" title="Identifier for document archives created by the document controller. This ID must be globally unique ...">ARAFactory::documentArchiveID</a>. The plug-in also returns whether openAutomatically should be set in the audio file chunk. Result is kARAFalse if the access to the archive writer failed while trying to write the archive, kARATrue otherwise. The host is responsible for alerting the user about archive write errors, see <a class="el" href="group___host___archiving___controller.html#a39ccce1c9ea18b0303e5633c8b0ddefd" title="Write bytes. This may only be called from storeObjectsToArchive() or the deprecated storeDocumentToAr...">ARAArchivingControllerInterface::writeBytesToArchive()</a>. <br /></td></tr>
<tr class="separator:a4759249602a579d2d561745eaa92182a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Document Management</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp04ab7e9520f65aa6c1c1c1eb8c397873"></a>As with all model graph edits, calling these functions must be guarded by <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. </p>
</td></tr>
<tr class="memitem:a65806061dcb8217e8b033341d4e51ed8"><td class="memItemLeft" align="right" valign="top"><a id="a65806061dcb8217e8b033341d4e51ed8"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a65806061dcb8217e8b033341d4e51ed8">updateDocumentProperties</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, const <a class="el" href="group___model___document.html#struct_a_r_a_document_properties">ARADocumentProperties</a> *properties)</td></tr>
<tr class="memdesc:a65806061dcb8217e8b033341d4e51ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of the controller's document. All properties must be specified, the plug-in will determine which have actually changed. <br /></td></tr>
<tr class="separator:a65806061dcb8217e8b033341d4e51ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Musical Context Management</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa3667d54d8707b4f640b95096df104d1"></a>As with all model graph edits, calling these functions must be guarded by <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. </p>
</td></tr>
<tr class="memitem:a3772a742ab0c6b0e0a1c73b9bd23fe10"><td class="memItemLeft" align="right" valign="top"><a id="a3772a742ab0c6b0e0a1c73b9bd23fe10"></a>
<a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a3772a742ab0c6b0e0a1c73b9bd23fe10">createMusicalContext</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___musical___context.html#ga43976cbd88a15e2b89d66ea2c019619b">ARAMusicalContextHostRef</a> hostRef, const <a class="el" href="group___model___musical___context.html#struct_a_r_a_musical_context_properties">ARAMusicalContextProperties</a> *properties)</td></tr>
<tr class="memdesc:a3772a742ab0c6b0e0a1c73b9bd23fe10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new musical context associated with the controller's document. <br /></td></tr>
<tr class="separator:a3772a742ab0c6b0e0a1c73b9bd23fe10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07987e7f0ce8524e4412f364ab830620"><td class="memItemLeft" align="right" valign="top"><a id="a07987e7f0ce8524e4412f364ab830620"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a07987e7f0ce8524e4412f364ab830620">updateMusicalContextProperties</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a> musicalContextRef, const <a class="el" href="group___model___musical___context.html#struct_a_r_a_musical_context_properties">ARAMusicalContextProperties</a> *properties)</td></tr>
<tr class="memdesc:a07987e7f0ce8524e4412f364ab830620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of a given musical context. All properties must be specified, the plug-in will determine which have actually changed. <br /></td></tr>
<tr class="separator:a07987e7f0ce8524e4412f364ab830620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa1747d10db24d62e811cf4947c8aee"><td class="memItemLeft" align="right" valign="top"><a id="adfa1747d10db24d62e811cf4947c8aee"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#adfa1747d10db24d62e811cf4947c8aee">updateMusicalContextContent</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a> musicalContextRef, const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *range, <a class="el" href="group___model___content___updates.html#ga74195b82b008866a82ca9dc2d226485c">ARAContentUpdateFlags</a> flags)</td></tr>
<tr class="memdesc:adfa1747d10db24d62e811cf4947c8aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the plug-in to update the information obtainable via content readers for a given musical context. The time range may be NULL, this means that the entire musical content is affected. Creating a new musical context implies an initial content update for it - the host will call this explicitly only for later content updates. <br /></td></tr>
<tr class="separator:adfa1747d10db24d62e811cf4947c8aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6645409d8c95ca0d16855a4d974d7c"><td class="memItemLeft" align="right" valign="top"><a id="a5a6645409d8c95ca0d16855a4d974d7c"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a5a6645409d8c95ca0d16855a4d974d7c">destroyMusicalContext</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___musical___context.html#ga2c325a59d193ccac258336c6e72416f7">ARAMusicalContextRef</a> musicalContextRef)</td></tr>
<tr class="memdesc:a5a6645409d8c95ca0d16855a4d974d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a given musical context. Destroying a musical context also implies removing it from its document. The musical context must no longer be referred to by any playback region when making this call. <br /></td></tr>
<tr class="separator:a5a6645409d8c95ca0d16855a4d974d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Audio Source Management</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpeb51019055242e32e9d19f0220a51a3e"></a>As with all model graph edits, calling these functions must be guarded by <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>, with the exception of <a class="el" href="group___plug-_in___document___controller.html#a25219110cde06efeceeda830a23be94a" title="Enable or disable access to a given audio source. This call allows the host to control the time when ...">enableAudioSourceSamplesAccess()</a> (which is no model graph edit, but but still has to occur on the ARA model thread). </p>
</td></tr>
<tr class="memitem:a1d587466e922d4d7288f9b51982a9ab1"><td class="memItemLeft" align="right" valign="top"><a id="a1d587466e922d4d7288f9b51982a9ab1"></a>
<a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a1d587466e922d4d7288f9b51982a9ab1">createAudioSource</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#gae2713ff3141693215d2b4da01b1ac445">ARAAudioSourceHostRef</a> hostRef, const <a class="el" href="group___model___audio___source.html#struct_a_r_a_audio_source_properties">ARAAudioSourceProperties</a> *properties)</td></tr>
<tr class="memdesc:a1d587466e922d4d7288f9b51982a9ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new audio source associated with the controller's document. The newly created audio source has its sample data access initially disabled, an explicit call to <a class="el" href="group___plug-_in___document___controller.html#a25219110cde06efeceeda830a23be94a" title="Enable or disable access to a given audio source. This call allows the host to control the time when ...">enableAudioSourceSamplesAccess()</a> is needed. <br /></td></tr>
<tr class="separator:a1d587466e922d4d7288f9b51982a9ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5e849f0bc7da4bc613ad4fb839ea7d"><td class="memItemLeft" align="right" valign="top"><a id="a2b5e849f0bc7da4bc613ad4fb839ea7d"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a2b5e849f0bc7da4bc613ad4fb839ea7d">updateAudioSourceProperties</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, const <a class="el" href="group___model___audio___source.html#struct_a_r_a_audio_source_properties">ARAAudioSourceProperties</a> *properties)</td></tr>
<tr class="memdesc:a2b5e849f0bc7da4bc613ad4fb839ea7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of a given audio source. Depending on which properties are changed (see documentation of <a class="el" href="group___model___audio___source.html#struct_a_r_a_audio_source_properties" title="Audio source properties. Note that like all properties, a pointer to this struct is only valid for th...">ARAAudioSourceProperties</a>), the host may not be able to make this call while the plug-in is reading data - in that case, use <a class="el" href="group___plug-_in___document___controller.html#a25219110cde06efeceeda830a23be94a" title="Enable or disable access to a given audio source. This call allows the host to control the time when ...">enableAudioSourceSamplesAccess()</a> accordingly. All properties must be specified, the plug-in will determine which have actually changed. <br /></td></tr>
<tr class="separator:a2b5e849f0bc7da4bc613ad4fb839ea7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb637639ba97aa8f7aa49c85f49c4f38"><td class="memItemLeft" align="right" valign="top"><a id="abb637639ba97aa8f7aa49c85f49c4f38"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#abb637639ba97aa8f7aa49c85f49c4f38">updateAudioSourceContent</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *range, <a class="el" href="group___model___content___updates.html#ga74195b82b008866a82ca9dc2d226485c">ARAContentUpdateFlags</a> flags)</td></tr>
<tr class="memdesc:abb637639ba97aa8f7aa49c85f49c4f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the plug-in that the sample data or content information for the given audio source has changed. Not to be called in response to <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a>. The time range may be NULL, this means that the entire audio source is affected. When implementing this call, remember to also flush any caches of the sampled data if needed (see <a class="el" href="group___model___content___updates.html#gga74195b82b008866a82ca9dc2d226485ca34fb9ac9367757d532012c08185eac8b" title="The actual signal is unaffected by the change. Note that in some cases even when the signal is consid...">kARAContentUpdateSignalScopeRemainsUnchanged</a>). Creating a new audio source always implies an initial content update for it, i.e. the host will call this function only for later content updates. Since audio sources are persistent, plug-ins should preferably postpone the initial content reading until <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> - if the host is restoring the audio source, this will remove the need to read initial content. <br /></td></tr>
<tr class="separator:abb637639ba97aa8f7aa49c85f49c4f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25219110cde06efeceeda830a23be94a"><td class="memItemLeft" align="right" valign="top"><a id="a25219110cde06efeceeda830a23be94a"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a25219110cde06efeceeda830a23be94a">enableAudioSourceSamplesAccess</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a> enable)</td></tr>
<tr class="memdesc:a25219110cde06efeceeda830a23be94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable access to a given audio source. This call allows the host to control the time when the plug-in may access sample data from the given audio source. Disabling access forces the plug-in to destroy all audio readers it currently has created for the affected audio source. This is a synchronous call, blocking until all currently executing reads of the audio source are finished. Access is disabled by default, hosts must explicitly enable it after creating an audio source. Since this call does not modify the model graph, it may be called outside the usual <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> scope. Note that disabling access will also abort any analysis currently being executed for the audio source, making it necessary to start it from scratch when the access is enabled again. This means that <a class="el" href="group___plug-_in___document___controller.html#a25219110cde06efeceeda830a23be94a" title="Enable or disable access to a given audio source. This call allows the host to control the time when ...">enableAudioSourceSamplesAccess()</a> is an expensive call that only should be made when necessary. It should not be (ab-)used to simply "pause ARA" whenever convenient. <br /></td></tr>
<tr class="separator:a25219110cde06efeceeda830a23be94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ac14fe2e666eab8a6f63e1cebc7a70"><td class="memItemLeft" align="right" valign="top"><a id="a85ac14fe2e666eab8a6f63e1cebc7a70"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a85ac14fe2e666eab8a6f63e1cebc7a70">deactivateAudioSourceForUndoHistory</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a> deactivate)</td></tr>
<tr class="memdesc:a85ac14fe2e666eab8a6f63e1cebc7a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate the given audio source because it has become part of the undo history and is no longer used actively. The plug-in will cancel any pending analysis for this audio source and may free some memory that is only needed when the audio source can be edited or rendered. Before deactivating an audio source, the host must deactivate all connected audio modifications first, and the opposite order is required when re-activating upon redo. When deactivated, updating the properties or content of the audio source or reading its content is no longer valid. Like properties, deactivation is not necessarily persistent in the plug-in, so the host must call this explicitly when restoring deactivated audio sources. <br /></td></tr>
<tr class="separator:a85ac14fe2e666eab8a6f63e1cebc7a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4c0658ea8478650ac8d135a1c855a6"><td class="memItemLeft" align="right" valign="top"><a id="a9c4c0658ea8478650ac8d135a1c855a6"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a9c4c0658ea8478650ac8d135a1c855a6">destroyAudioSource</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef)</td></tr>
<tr class="memdesc:a9c4c0658ea8478650ac8d135a1c855a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a given audio source. Destroying an audio source also implies removing it from its document. The host must delete all objects associated with the audio source (audio modifications etc.) before deleting the audio source. The host does not need to explicitly disable access to the audio source before making this call. <br /></td></tr>
<tr class="separator:a9c4c0658ea8478650ac8d135a1c855a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Audio Modification Management</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb713d454f62eda82c9b7076abc0aa5ad"></a>As with all model graph edits, calling these functions must be guarded by <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. </p>
</td></tr>
<tr class="memitem:aef8e7391a24b3c2e615fcaf6dcd9912c"><td class="memItemLeft" align="right" valign="top"><a id="aef8e7391a24b3c2e615fcaf6dcd9912c"></a>
<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#aef8e7391a24b3c2e615fcaf6dcd9912c">createAudioModification</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___model___audio___modification.html#ga4fcadfe860312728c065593e1f7cf104">ARAAudioModificationHostRef</a> hostRef, const <a class="el" href="group___model___audio___modification.html#struct_a_r_a_audio_modification_properties">ARAAudioModificationProperties</a> *properties)</td></tr>
<tr class="memdesc:aef8e7391a24b3c2e615fcaf6dcd9912c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new audio modification associated with the given audio source. <br /></td></tr>
<tr class="separator:aef8e7391a24b3c2e615fcaf6dcd9912c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df98bdd99491de69fee1902d6c2e983"><td class="memItemLeft" align="right" valign="top"><a id="a3df98bdd99491de69fee1902d6c2e983"></a>
<a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a3df98bdd99491de69fee1902d6c2e983">cloneAudioModification</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___model___audio___modification.html#ga4fcadfe860312728c065593e1f7cf104">ARAAudioModificationHostRef</a> hostRef, const <a class="el" href="group___model___audio___modification.html#struct_a_r_a_audio_modification_properties">ARAAudioModificationProperties</a> *properties)</td></tr>
<tr class="memdesc:a3df98bdd99491de69fee1902d6c2e983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new audio modification that copies the state of another given audio modification. The new modification will be associated with the same audio source. This call is used to create independent variations of the audio as opposed to creating aliases by merely adding playback regions to a given audio modification. <br /></td></tr>
<tr class="separator:a3df98bdd99491de69fee1902d6c2e983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17379cccc3bd0e679db2d4225d870ac6"><td class="memItemLeft" align="right" valign="top"><a id="a17379cccc3bd0e679db2d4225d870ac6"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a17379cccc3bd0e679db2d4225d870ac6">updateAudioModificationProperties</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, const <a class="el" href="group___model___audio___modification.html#struct_a_r_a_audio_modification_properties">ARAAudioModificationProperties</a> *properties)</td></tr>
<tr class="memdesc:a17379cccc3bd0e679db2d4225d870ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of a given audio modification. All properties must be specified, the plug-in will determine which have actually changed. <br /></td></tr>
<tr class="separator:a17379cccc3bd0e679db2d4225d870ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9057c8727a09fd088d11cdc9a30d9b"><td class="memItemLeft" align="right" valign="top"><a id="afe9057c8727a09fd088d11cdc9a30d9b"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#afe9057c8727a09fd088d11cdc9a30d9b">deactivateAudioModificationForUndoHistory</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a> deactivate)</td></tr>
<tr class="memdesc:afe9057c8727a09fd088d11cdc9a30d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate the given audio modification because it has become part of the undo history and is no longer used actively. The plug-in may free some memory that is only needed when the audio modification can be edited or rendered. When deactivated, updating the properties of the audio modification or reading its content is no longer valid. Like properties, deactivation is not necessarily persistent in the plug-in, so the host must call this explicitly when restoring deactivated audio modifications. <br /></td></tr>
<tr class="separator:afe9057c8727a09fd088d11cdc9a30d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf03441f4dac3c4ce4bd13766bb30ca"><td class="memItemLeft" align="right" valign="top"><a id="adaf03441f4dac3c4ce4bd13766bb30ca"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#adaf03441f4dac3c4ce4bd13766bb30ca">destroyAudioModification</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef)</td></tr>
<tr class="memdesc:adaf03441f4dac3c4ce4bd13766bb30ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a given audio modification. Destroying an audio modification also implies removing it from its audio source. The host must delete all objects associated with the audio modification (playback regions etc.) before deleting the audio modification. <br /></td></tr>
<tr class="separator:adaf03441f4dac3c4ce4bd13766bb30ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Playback Region Management</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7f34e98b6ebc427fe4593ff45d16f1d9"></a>As with all model graph edits, calling these functions must be guarded by <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. </p>
</td></tr>
<tr class="memitem:adb3590c8ec4191d08330f989c34e0a63"><td class="memItemLeft" align="right" valign="top"><a id="adb3590c8ec4191d08330f989c34e0a63"></a>
<a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#adb3590c8ec4191d08330f989c34e0a63">createPlaybackRegion</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___model___playback___region.html#ga69daf0d4cf4ca3cf9acf2874ca1dc682">ARAPlaybackRegionHostRef</a> hostRef, const <a class="el" href="group___model___playback___region.html#struct_a_r_a_playback_region_properties">ARAPlaybackRegionProperties</a> *properties)</td></tr>
<tr class="memdesc:adb3590c8ec4191d08330f989c34e0a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new playback region associated with the given audio modification. <br /></td></tr>
<tr class="separator:adb3590c8ec4191d08330f989c34e0a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a4bf57528e782fc0182b4246227b57"><td class="memItemLeft" align="right" valign="top"><a id="ac1a4bf57528e782fc0182b4246227b57"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#ac1a4bf57528e782fc0182b4246227b57">updatePlaybackRegionProperties</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef, const <a class="el" href="group___model___playback___region.html#struct_a_r_a_playback_region_properties">ARAPlaybackRegionProperties</a> *properties)</td></tr>
<tr class="memdesc:ac1a4bf57528e782fc0182b4246227b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of a given playback region. All properties must be specified, the plug-in will determine which have actually changed. <br /></td></tr>
<tr class="separator:ac1a4bf57528e782fc0182b4246227b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7ce235d69ae57ee3c64921fb7f32b6"><td class="memItemLeft" align="right" valign="top"><a id="a6a7ce235d69ae57ee3c64921fb7f32b6"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a6a7ce235d69ae57ee3c64921fb7f32b6">destroyPlaybackRegion</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef)</td></tr>
<tr class="memdesc:a6a7ce235d69ae57ee3c64921fb7f32b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a given playback region. Destroying a playback region also implies removing it from its audio modification. The playback region must no longer be referred to by any plug-in extension when making this call. <br /></td></tr>
<tr class="separator:a6a7ce235d69ae57ee3c64921fb7f32b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Content Reader Management</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc73b8a2485ca1d8975a7b4cbb1b10632"></a>Content readers are not model objects but rather auxiliary objects to parse content without extensive data copying, following a standard iterator pattern. As is common with iterators, no changes may be made to the model graph while reading content. Prior to the final release of ARA 2.0, this meant that making any of the content related calls was limited to be done outside of pairs of <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. Since version 2_0_Final, it is also valid to use them while the document is in editing state, but no other call to this document controller may be made in-between a series of content related calls (except for <a class="el" href="group___plug-_in___document___controller.html#a792202b3ee87c028ea704752f36abb19" title="Query the static ARA factory that was used to create this controller. This provides a convenient trav...">getFactory()</a> and <a class="el" href="group___plug-_in___document___controller.html#a98933f9a46ef4726335aab1930971a90" title="Query the current head and tail time of a given playback region. Note that when a plug-in optimizes r...">getPlaybackRegionHeadAndTailTime()</a>). For example for a given audio source such a series of calls typically would be <a class="el" href="group___plug-_in___document___controller.html#a15500d908dfd692ff7d6b5a026a37e53" title="Query whether the given content type is currently available for the given audio source.">isAudioSourceContentAvailable()</a>, <a class="el" href="group___plug-_in___document___controller.html#a5fe2ff4b0649f9f88201ade1a87bb7e4" title="Query the current quality of the information provided for the given audio source and content type.">getAudioSourceContentGrade()</a>, <a class="el" href="group___plug-_in___document___controller.html#ac5159eb72fba9f9fc0f4b867786d3732" title="Create a content reader for the given audio source and content type. This should only be called after...">createAudioSourceContentReader()</a>, <a class="el" href="group___plug-_in___document___controller.html#af6948ce19f1b7504dcbde0d5e9d38117" title="Query how many events the given reader exposes.">getContentReaderEventCount()</a>, n times <a class="el" href="group___plug-_in___document___controller.html#a69a8b85e86d21ff4d626179b7a0a0dfb" title="Query data of the given event of the given reader. The returned pointer is owned by the plug-in and m...">getContentReaderDataForEvent()</a>, <a class="el" href="group___plug-_in___document___controller.html#aa5cb32205ee9029985a5b5d4dda7cfd8" title="Destroy the given content reader.">destroyContentReader()</a>. Typically, content readers are temporary local objects on the stack of the ARA model thread, which naturally satisfies these conditions. This change is mainly intended to support partial persistency introduced with ARA 2.0, since it allows hosts to read content of imported audio sources/modifications to adjust the playback regions accordingly without toggling the editing state of the document back and forth. </p>
</td></tr>
<tr class="memitem:a15500d908dfd692ff7d6b5a026a37e53"><td class="memItemLeft" align="right" valign="top"><a id="a15500d908dfd692ff7d6b5a026a37e53"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a15500d908dfd692ff7d6b5a026a37e53">isAudioSourceContentAvailable</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType)</td></tr>
<tr class="memdesc:a15500d908dfd692ff7d6b5a026a37e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the given content type is currently available for the given audio source. <br /></td></tr>
<tr class="separator:a15500d908dfd692ff7d6b5a026a37e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e759196ba8cb5dfcdf2cb837c0578d3"><td class="memItemLeft" align="right" valign="top"><a id="a3e759196ba8cb5dfcdf2cb837c0578d3"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a3e759196ba8cb5dfcdf2cb837c0578d3">isAudioSourceContentAnalysisIncomplete</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType)</td></tr>
<tr class="memdesc:a3e759196ba8cb5dfcdf2cb837c0578d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether an analysis of the given content type has been done for the given audio source. This call will typically be used when the host uses the plug-in as a detection engine in the background (i.e. without presenting the UI to the user). In that scenario, the host will trigger the analysis of the desired content types using <a class="el" href="group___plug-_in___document___controller.html#a7b0614d5cb41666b742e5721dfe39de3" title="Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine,...">requestAudioSourceContentAnalysis()</a> and then wait until the plug-in calls <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a>. From that call, the host will query the plug-in via <a class="el" href="group___plug-_in___document___controller.html#a3e759196ba8cb5dfcdf2cb837c0578d3" title="Query whether an analysis of the given content type has been done for the given audio source....">isAudioSourceContentAnalysisIncomplete()</a> to determine which of the analysis requests have completed. If the host did request a specific algorithm to be used, then the plug-in should return kARATrue here until the request was satisfied (or rejected). <br /></td></tr>
<tr class="separator:a3e759196ba8cb5dfcdf2cb837c0578d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0614d5cb41666b742e5721dfe39de3"><td class="memItemLeft" align="right" valign="top"><a id="a7b0614d5cb41666b742e5721dfe39de3"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a7b0614d5cb41666b742e5721dfe39de3">requestAudioSourceContentAnalysis</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a> contentTypesCount, const <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentTypes[])</td></tr>
<tr class="memdesc:a7b0614d5cb41666b742e5721dfe39de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine, it needs to explicitly trigger the desired analysis, since otherwise the plug-in may postpone any analysis as suitable. To allow for optimizing the analysis on the plug-in side, all content types that are of interest for the host should be specified in a single call if possible.  <br>                               Note that the plug-in may choose to perform any additional analysis at any point in time if this is appropriate for its design. It will call <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a> if such an analysis concludes successfully so that the host can update accordingly.  <br>                               The provided content types must be a non-empty subset of the plug-in's <a class="el" href="group___plug-_in___factory.html#abdefa00d5ef9074c3563d58265361525" title="Variable-sized C array listing the content types for which the plug-in can perform an analysis....">ARAFactory::analyzeableContentTypes</a>. To request all analysis types exported by the plug-in, hosts can directly pass analyzeableContentTypes and -Count from the plug-in's <a class="el" href="group___plug-_in___factory.html#struct_a_r_a_factory" title="Static plug-in factory. All pointers herein must remain valid as long as the binary is loaded....">ARAFactory</a>. The contentTypes pointer may be only valid for the duration of the call, it must be evaluated inside the call, and the pointer must not be stored anywhere.  <br>                               Note that ARA 2.0 adds the capability for the host to also request the use of a certain processing algorithm via <a class="el" href="group___plug-_in___document___controller.html#a246007af61e57a48c5167d81801af48d" title="Request that any future analysis of the given audio source should use the given processing algorithm....">requestProcessingAlgorithmForAudioSource()</a> - if both are used then the algorithm must be selected before requesting the analysis. <br /></td></tr>
<tr class="separator:a7b0614d5cb41666b742e5721dfe39de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe2ff4b0649f9f88201ade1a87bb7e4"><td class="memItemLeft" align="right" valign="top"><a id="a5fe2ff4b0649f9f88201ade1a87bb7e4"></a>
<a class="el" href="group___model___content___readers__and___content___events.html#ga91aa126b597a1b08dfcd01b2778ab734">ARAContentGrade</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a5fe2ff4b0649f9f88201ade1a87bb7e4">getAudioSourceContentGrade</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType)</td></tr>
<tr class="memdesc:a5fe2ff4b0649f9f88201ade1a87bb7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current quality of the information provided for the given audio source and content type. <br /></td></tr>
<tr class="separator:a5fe2ff4b0649f9f88201ade1a87bb7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5159eb72fba9f9fc0f4b867786d3732"><td class="memItemLeft" align="right" valign="top"><a id="ac5159eb72fba9f9fc0f4b867786d3732"></a>
<a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#ac5159eb72fba9f9fc0f4b867786d3732">createAudioSourceContentReader</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType, const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *range)</td></tr>
<tr class="memdesc:ac5159eb72fba9f9fc0f4b867786d3732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a content reader for the given audio source and content type. This should only be called after availability has been confirmed using <a class="el" href="group___plug-_in___document___controller.html#a15500d908dfd692ff7d6b5a026a37e53" title="Query whether the given content type is currently available for the given audio source.">isAudioSourceContentAvailable()</a>. The time range may be NULL, which means that the entire audio source shall be read. If a time range is specified, all events that at least partially intersect with the range will be read. <br /></td></tr>
<tr class="separator:ac5159eb72fba9f9fc0f4b867786d3732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983a0f1b6c4d13cf7aed661c442d9759"><td class="memItemLeft" align="right" valign="top"><a id="a983a0f1b6c4d13cf7aed661c442d9759"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a983a0f1b6c4d13cf7aed661c442d9759">isAudioModificationContentAvailable</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType)</td></tr>
<tr class="memdesc:a983a0f1b6c4d13cf7aed661c442d9759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the given content type is currently available for the given audio modification. Note that since ARA 2.0, reading at playback region level is recommended for most content types, see <a class="el" href="group___plug-_in___document___controller.html#aa883fc189384d66d2b2b9bbf8d41cc34" title="Create a content reader for the given audio modification and content type. This should only be called...">createAudioModificationContentReader()</a>. <br /></td></tr>
<tr class="separator:a983a0f1b6c4d13cf7aed661c442d9759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e52489f32f021e85f30a8f6a47b0ba"><td class="memItemLeft" align="right" valign="top"><a id="ad2e52489f32f021e85f30a8f6a47b0ba"></a>
<a class="el" href="group___model___content___readers__and___content___events.html#ga91aa126b597a1b08dfcd01b2778ab734">ARAContentGrade</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#ad2e52489f32f021e85f30a8f6a47b0ba">getAudioModificationContentGrade</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType)</td></tr>
<tr class="memdesc:ad2e52489f32f021e85f30a8f6a47b0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current quality of the information provided for a given audio modification and content type. Note that since ARA 2.0, reading at playback region level is recommended for most content types, see <a class="el" href="group___plug-_in___document___controller.html#aa883fc189384d66d2b2b9bbf8d41cc34" title="Create a content reader for the given audio modification and content type. This should only be called...">createAudioModificationContentReader()</a>. <br /></td></tr>
<tr class="separator:ad2e52489f32f021e85f30a8f6a47b0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa883fc189384d66d2b2b9bbf8d41cc34"><td class="memItemLeft" align="right" valign="top"><a id="aa883fc189384d66d2b2b9bbf8d41cc34"></a>
<a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#aa883fc189384d66d2b2b9bbf8d41cc34">createAudioModificationContentReader</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___modification.html#gae04722e89e1143ea3cd9b947ce891889">ARAAudioModificationRef</a> audioModificationRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType, const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *range)</td></tr>
<tr class="memdesc:aa883fc189384d66d2b2b9bbf8d41cc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a content reader for the given audio modification and content type. This should only be called after availability has been confirmed using <a class="el" href="group___plug-_in___document___controller.html#a983a0f1b6c4d13cf7aed661c442d9759" title="Query whether the given content type is currently available for the given audio modification....">isAudioModificationContentAvailable()</a>. The time range may be NULL, which means that the entire audio modification shall be read. If a time range is specified, all events that at least partially intersect with the range will be read. Note that with the introduction of region transitions in ARA 2.0, the content of a given playback region can no longer be externally calculated by the host based on the content of its underlying audio modification and the transformation flags. Instead, hosts should read such content directly at region level. This particularly applies to kARAContentTypeNotes - notes at borders will be adjusted on a per-region basis when using content based fades. Playback region content reading is available in ARA 1.0 already, thus such an implementation will be fully backwards compatible. Reading content at audio modification (or audio source) level is still valid and useful if the host needs access to the content in its original state, not transformed by a playback region, e.g. when implementing features such as tempo and signature detection through ARA. <br /></td></tr>
<tr class="separator:aa883fc189384d66d2b2b9bbf8d41cc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67131e6287cb48dae3c0932b5bb646a8"><td class="memItemLeft" align="right" valign="top"><a id="a67131e6287cb48dae3c0932b5bb646a8"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a67131e6287cb48dae3c0932b5bb646a8">isPlaybackRegionContentAvailable</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType)</td></tr>
<tr class="memdesc:a67131e6287cb48dae3c0932b5bb646a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the given content type is currently available for the given playback region. <br /></td></tr>
<tr class="separator:a67131e6287cb48dae3c0932b5bb646a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591b7ca238453f2db1a8b3955343cfea"><td class="memItemLeft" align="right" valign="top"><a id="a591b7ca238453f2db1a8b3955343cfea"></a>
<a class="el" href="group___model___content___readers__and___content___events.html#ga91aa126b597a1b08dfcd01b2778ab734">ARAContentGrade</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a591b7ca238453f2db1a8b3955343cfea">getPlaybackRegionContentGrade</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType)</td></tr>
<tr class="memdesc:a591b7ca238453f2db1a8b3955343cfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current quality of the information provided for the given playback region and content type. <br /></td></tr>
<tr class="separator:a591b7ca238453f2db1a8b3955343cfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cbb377987849f2d81cf461f89b0fed"><td class="memItemLeft" align="right" valign="top"><a id="a21cbb377987849f2d81cf461f89b0fed"></a>
<a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a21cbb377987849f2d81cf461f89b0fed">createPlaybackRegionContentReader</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef, <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentType, const <a class="el" href="group___model___content___readers__and___content___events.html#struct_a_r_a_content_time_range">ARAContentTimeRange</a> *range)</td></tr>
<tr class="memdesc:a21cbb377987849f2d81cf461f89b0fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a content reader for the given playback region and content type. This should only be called after availability has been confirmed using <a class="el" href="group___plug-_in___document___controller.html#a67131e6287cb48dae3c0932b5bb646a8" title="Query whether the given content type is currently available for the given playback region.">isPlaybackRegionContentAvailable()</a>. The time range may be NULL, which means that the entire playback region shall be read, including its potential head and tail time. If a time range is specified, all events that at least partially intersect with the range will be read. The time range must be given in playback time, and the time stamps provided by the content reader are in playback time as well. <br /></td></tr>
<tr class="separator:a21cbb377987849f2d81cf461f89b0fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6948ce19f1b7504dcbde0d5e9d38117"><td class="memItemLeft" align="right" valign="top"><a id="af6948ce19f1b7504dcbde0d5e9d38117"></a>
<a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#af6948ce19f1b7504dcbde0d5e9d38117">getContentReaderEventCount</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a> contentReaderRef)</td></tr>
<tr class="memdesc:af6948ce19f1b7504dcbde0d5e9d38117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query how many events the given reader exposes. <br /></td></tr>
<tr class="separator:af6948ce19f1b7504dcbde0d5e9d38117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a8b85e86d21ff4d626179b7a0a0dfb"><td class="memItemLeft" align="right" valign="top"><a id="a69a8b85e86d21ff4d626179b7a0a0dfb"></a>
const void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a69a8b85e86d21ff4d626179b7a0a0dfb">getContentReaderDataForEvent</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a> contentReaderRef, <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a> eventIndex)</td></tr>
<tr class="memdesc:a69a8b85e86d21ff4d626179b7a0a0dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query data of the given event of the given reader. The returned pointer is owned by the plug-in and must remain valid until either <a class="el" href="group___plug-_in___document___controller.html#a69a8b85e86d21ff4d626179b7a0a0dfb" title="Query data of the given event of the given reader. The returned pointer is owned by the plug-in and m...">getContentReaderDataForEvent()</a> is called again or the content reader is destroyed. <br /></td></tr>
<tr class="separator:a69a8b85e86d21ff4d626179b7a0a0dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cb32205ee9029985a5b5d4dda7cfd8"><td class="memItemLeft" align="right" valign="top"><a id="aa5cb32205ee9029985a5b5d4dda7cfd8"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#aa5cb32205ee9029985a5b5d4dda7cfd8">destroyContentReader</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___content___readers__and___content___events.html#gaf273e132822d8cc487161970877bdd43">ARAContentReaderRef</a> contentReaderRef)</td></tr>
<tr class="memdesc:aa5cb32205ee9029985a5b5d4dda7cfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the given content reader. <br /></td></tr>
<tr class="separator:aa5cb32205ee9029985a5b5d4dda7cfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Region Sequence Management (added in ARA 2.0)</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5cd7cf30402276cca122c1cfde5c7047"></a>As with all model graph edits, calling these functions must be guarded by <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. </p>
</td></tr>
<tr class="memitem:a9b2859f60a28605823fe5555f39102dd"><td class="memItemLeft" align="right" valign="top"><a id="a9b2859f60a28605823fe5555f39102dd"></a>
<a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a9b2859f60a28605823fe5555f39102dd">createRegionSequence</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___region___sequences.html#gae00b011383547d39b0ad55e2e908a248">ARARegionSequenceHostRef</a> hostRef, const <a class="el" href="group___model___region___sequences.html#struct_a_r_a_region_sequence_properties">ARARegionSequenceProperties</a> *properties)</td></tr>
<tr class="memdesc:a9b2859f60a28605823fe5555f39102dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new region sequence associated with the controller's document. <br /></td></tr>
<tr class="separator:a9b2859f60a28605823fe5555f39102dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b70f0afa3cc5d70cb4bf91aac25c0"><td class="memItemLeft" align="right" valign="top"><a id="af61b70f0afa3cc5d70cb4bf91aac25c0"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#af61b70f0afa3cc5d70cb4bf91aac25c0">updateRegionSequenceProperties</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a> regionSequenceRef, const <a class="el" href="group___model___region___sequences.html#struct_a_r_a_region_sequence_properties">ARARegionSequenceProperties</a> *properties)</td></tr>
<tr class="memdesc:af61b70f0afa3cc5d70cb4bf91aac25c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the properties of a given region sequence. All properties must be specified, the plug-in will determine which have actually changed. <br /></td></tr>
<tr class="separator:af61b70f0afa3cc5d70cb4bf91aac25c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad0176a72317ed4e903a2b5e7c7e1b0"><td class="memItemLeft" align="right" valign="top"><a id="afad0176a72317ed4e903a2b5e7c7e1b0"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#afad0176a72317ed4e903a2b5e7c7e1b0">destroyRegionSequence</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___region___sequences.html#gad39b81cde8680cc991430bd0fb578367">ARARegionSequenceRef</a> regionSequenceRef)</td></tr>
<tr class="memdesc:afad0176a72317ed4e903a2b5e7c7e1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a given region sequence. The region sequence must no longer be referred to by any playback region when making this call. <br /></td></tr>
<tr class="separator:afad0176a72317ed4e903a2b5e7c7e1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Playback Region Head and Tail Time (added in ARA 2.0)</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp26b6687af72c474a2a770fbee411fee3"></a>Depending on the specific DSP performed by the plug-in, the resulting signal for any region may exceed the region borders. Among other use cases such as delays, this will typically happen when the content based fades are enabled. Reporting this potential excess of signal both at start and end of a region allows for the host to adjust their rendering so that it includes head and tail time, or else fade the signal at the region borders to avoid crackles. This function can be called either from the model thread or from any (realtime or offline) audio rendering thread. If edits that the host performs on the model affect the head or tail times (such as toggling content based fades on or off), the new values can only be reliably queried on the model thread once <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> has returned. On audio threads, they can only be reliably queried until all render calls that may have occurred concurrently with <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a> have returned. </p>
</td></tr>
<tr class="memitem:a98933f9a46ef4726335aab1930971a90"><td class="memItemLeft" align="right" valign="top"><a id="a98933f9a46ef4726335aab1930971a90"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a98933f9a46ef4726335aab1930971a90">getPlaybackRegionHeadAndTailTime</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___playback___region.html#ga9f34c4bb513bc9b514d346c531b7fe8b">ARAPlaybackRegionRef</a> playbackRegionRef, <a class="el" href="group___common__time-related__data__types.html#gaae0f11efaa1db78be29766f7bb5627f1">ARATimeDuration</a> *headTime, <a class="el" href="group___common__time-related__data__types.html#gaae0f11efaa1db78be29766f7bb5627f1">ARATimeDuration</a> *tailTime)</td></tr>
<tr class="memdesc:a98933f9a46ef4726335aab1930971a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current head and tail time of a given playback region. Note that when a plug-in optimizes region transitions, the head and tail of any given region can change upon any model edit, even if it is not directly affected by the edit. Also, in order to properly track interaction between regions, plug-ins may lazily update this information upon <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. Plug-ins will call notifyPlaybackRegionContentChanged() whenever these values change. headTime and tailTime must not be NULL. Host may query this often, so plug-ins should cache the value if there's any expensive calculation involved. Note that most companion APIs also feature a tail time concept. For playback renderer plug-in instances, the tail time reported via the companion API should be equal to or greater than the maximum of the tail times of all playback regions currently associated with the given renderer (i.e. the tail for any given playback region may be somewhat shorter then the companion API tail, depending on the region's content). <br /></td></tr>
<tr class="separator:a98933f9a46ef4726335aab1930971a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Processing Algorithm Selection (added in ARA 2.0)</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf446e60bf6c6baef7525c16faad1624d"></a>Many plug-ins feature a set of different processing algorithms, each suited for a given kind of audio material. When analyzing the audio, plug-ins either try to automatically determine the appropriate algorithm that best matches the nature of the given material, or delegate this decision to the user. This fundamental selection may affect all further processing of the audio source - in addition to the analysis results, internal editing and rendering parameters and even the entire UI may change. Accordingly, changing this selection may invalidate some or all edits done by the user in the audio modifications based on the audio source. To avoid such data loss, making this selection appropriately should always be the first step when working with audio sources. By exporting the list of processing algorithms here, hosts can implement this selection, based on their knowledge about the origin of the audio material. Some hosts allow for configuring their built-in detection in a very similar way on a per-track basis, usually via a menu. They can use this technique for compatible ARA plug-ins as well. Host might also be able to implicitly deduce an appropriate processing algorithm. For example, when adding a new audio source to a region sequence that already refers to a set of previously analyzed audio sources which all use the same detection algorithm, this algorithm is likely appropriate for the new audio source as well. Along the same lines, when recording a new take of some material that already has been analyzed by the plug-in, it is reasonable to use the same algorithm for the new take. Note that each processing algorithm must implement detection for all content types exported by the plug-in, albeit the detection quality may likely be different for some types. Plug-ins should keep the list of available processing algorithms restricted to the smallest reasonable set - after all, in an ideal (but currently not achievable) implementation, a single detection algorithm would be powerful enough to cover all types of material flawlessly. </p>
</td></tr>
<tr class="memitem:a6d19d64209660d3238fe944d2127b960"><td class="memItemLeft" align="right" valign="top"><a id="a6d19d64209660d3238fe944d2127b960"></a>
<a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a6d19d64209660d3238fe944d2127b960">getProcessingAlgorithmsCount</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef)</td></tr>
<tr class="memdesc:a6d19d64209660d3238fe944d2127b960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the count of processing algorithms provided by the plug-in. If this optional method is not implemented or the call returns 0, then the plug-in does not support algorithm selection through the host and the other related functions below must not be called. <br /></td></tr>
<tr class="separator:a6d19d64209660d3238fe944d2127b960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c6597932fa935557ffa83dd50639c4"><td class="memItemLeft" align="right" valign="top"><a id="a64c6597932fa935557ffa83dd50639c4"></a>
const <a class="el" href="group___processing___algorithm___selection.html#struct_a_r_a_processing_algorithm_properties">ARAProcessingAlgorithmProperties</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a64c6597932fa935557ffa83dd50639c4">getProcessingAlgorithmProperties</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a> algorithmIndex)</td></tr>
<tr class="memdesc:a64c6597932fa935557ffa83dd50639c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of processing algorithms provided by the plug-in, described by their properties. This method must be implemented if <a class="el" href="group___plug-_in___document___controller.html#a6d19d64209660d3238fe944d2127b960" title="Return the count of processing algorithms provided by the plug-in. If this optional method is not imp...">getProcessingAlgorithmsCount()</a> is implemented. Provides a unique identifier and a user-readable name of the algorithm as displayed in the plug-in. The host should present the algorithms to the user in the order of this list, e.g. in a menu. For a given version of the plug-in, the count and the order and values of the persistentIDs must be the same, while the names may depend on localization settings that can be different on different machines or between individual runs of the host. The list may however change between different versions of the plug-in. Both hosts and plug-ins must implement fallbacks for loading a document that contains an processing algorithm persistentID which is no longer supported by the plug-in. The pointers returned by this calls must remain valid until the document controller is destroyed. <br /></td></tr>
<tr class="separator:a64c6597932fa935557ffa83dd50639c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2a700a707b5837e5efeb9da86417c2"><td class="memItemLeft" align="right" valign="top"><a id="a8d2a700a707b5837e5efeb9da86417c2"></a>
<a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a8d2a700a707b5837e5efeb9da86417c2">getProcessingAlgorithmForAudioSource</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef)</td></tr>
<tr class="memdesc:a8d2a700a707b5837e5efeb9da86417c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query currently used processing algorithm for a given audio source. This method must be implemented if <a class="el" href="group___plug-_in___document___controller.html#a6d19d64209660d3238fe944d2127b960" title="Return the count of processing algorithms provided by the plug-in. If this optional method is not imp...">getProcessingAlgorithmsCount()</a> is implemented. After the plug-in has concluded an analysis (as indicated via <a class="el" href="group___host___model___update___controller___interface.html#a1a6775769ed85499fdb85a3f971a78b8" title="Message to the host when content of the given audio source changes. Not to be called if the change wa...">ARAModelUpdateControllerInterface::notifyAudioSourceContentChanged()</a>), the host can query which processing algorithm was used and update its UI accordingly. This is particularly relevant if the host did explicitly request an analysis with a specific algorithm, but the plug-in was unable to satisfy this request for some reason. Similarly, the user may have changed the algorithm through the plug-in's UI. Note that until the first analysis has completed (i.e. as long as <a class="el" href="group___plug-_in___document___controller.html#a3e759196ba8cb5dfcdf2cb837c0578d3" title="Query whether an analysis of the given content type has been done for the given audio source....">isAudioSourceContentAnalysisIncomplete()</a> returns kARATrue), the value returned here may be an abstract default, not related to the actual audio source content. This will e.g. typically be the case in Melodyne, which uses an "automatic mode" as default until the first analysis has determined the actual processing algorithm that is suitable for the material. The call should not be made while <a class="el" href="group___plug-_in___document___controller.html#a3e759196ba8cb5dfcdf2cb837c0578d3" title="Query whether an analysis of the given content type has been done for the given audio source....">isAudioSourceContentAnalysisIncomplete()</a> returns kARATrue, because the returned value is likely stale. <br /></td></tr>
<tr class="separator:a8d2a700a707b5837e5efeb9da86417c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246007af61e57a48c5167d81801af48d"><td class="memItemLeft" align="right" valign="top"><a id="a246007af61e57a48c5167d81801af48d"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a246007af61e57a48c5167d81801af48d">requestProcessingAlgorithmForAudioSource</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___model___audio___source.html#ga6389a827a40ecfb56b44f4158a566a09">ARAAudioSourceRef</a> audioSourceRef, <a class="el" href="group___fixed-size__integers.html#gae89c0d982d17edbe5bac0a55255f38d6">ARAInt32</a> algorithmIndex)</td></tr>
<tr class="memdesc:a246007af61e57a48c5167d81801af48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that any future analysis of the given audio source should use the given processing algorithm. This method must be implemented if <a class="el" href="group___plug-_in___document___controller.html#a6d19d64209660d3238fe944d2127b960" title="Return the count of processing algorithms provided by the plug-in. If this optional method is not imp...">getProcessingAlgorithmsCount()</a> is implemented. This both affects any analysis requested by the host via <a class="el" href="group___plug-_in___document___controller.html#a7b0614d5cb41666b742e5721dfe39de3" title="Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine,...">requestAudioSourceContentAnalysis()</a> as well as any analysis done by the plug-in on demand. Since this typically results in a model graph edit, calling this functions must be guarded by <a class="el" href="group___plug-_in___document___controller.html#a73d999e8600d4b9576c3b18fe8dce16f" title="Start an editing session on a document. An editing session can contain an arbitrary set of modificati...">beginEditing()</a> and <a class="el" href="group___plug-_in___document___controller.html#ab4946909515472d8ea4f5f1ee5cac599" title="End an editing session on a document. Note that when receiving this call, the plug-in will update any...">endEditing()</a>. Note that the plug-in is not required to heed this request if its internal state suggest otherwise, or if the user switches actively to a different algorithm. Also, some algorithms may be "meta" algorithms that will be replaced by a different actual algorithm, such as the "automatic" default algorithm in Melodyne which will pick an appropriate algorithm from the remaining list of algorithms when doing the initial analysis. <br /></td></tr>
<tr class="separator:a246007af61e57a48c5167d81801af48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>License Management (added in ARA 2.0)</h3></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp90261f16688b50d4b72e7c9a46aef000"></a>If using ARA plug-ins for regular editing, their UI is shown and they can implement all license handling fully transparent for the host within their regular UI. If however the host is using the plug-in as internal engine for analysis (e.g. audio-to-MIDI conversion) or for time-stretching, it will typically not open the plug-in UI, and accordingly must then deal with potentially missing licenses that the plug-in requires to perform the desired tasks. As an example, Melodyne's analysis capabilities are only available when running Melodyne essential or higher, i.e. they are not supported by an unlicensed "playback-only" installation. </p>
</td></tr>
<tr class="memitem:a44c84dfdd1a2646e6ceb4170c56ba987"><td class="memItemLeft" align="right" valign="top"><a id="a44c84dfdd1a2646e6ceb4170c56ba987"></a>
<a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plug-_in___document___controller.html#a44c84dfdd1a2646e6ceb4170c56ba987">isLicensedForCapabilities</a> )(<a class="el" href="group___plug-_in___document___controller.html#ga8bff5d917f3cbcaf9febb7d5945ecb7d">ARADocumentControllerRef</a> controllerRef, <a class="el" href="group___boolean__values.html#ga49ea321bed3e4843a38702d03cc4cff0">ARABool</a> runModalActivationDialogIfNeeded, <a class="el" href="group___fixed-size__integers.html#ga146f863d090eb0291cb2f6c4d19c373e">ARASize</a> contentTypesCount, const <a class="el" href="group___model___content___readers__and___content___events.html#ga24de378fe088e091ac0bdd0467f5bcb8">ARAContentType</a> contentTypes[], <a class="el" href="group___model___playback___region.html#ga258336ff5f674225e3ec403493461179">ARAPlaybackTransformationFlags</a> transformationFlags)</td></tr>
<tr class="memdesc:a44c84dfdd1a2646e6ceb4170c56ba987"><td class="mdescLeft">&#160;</td><td class="mdescRight">With this optional call, hosts can test whether the current license state of the plug-in allows for requesting analysis of the given content types and rendering the given playback transformations (see <a class="el" href="group___plug-_in___document___controller.html#a7b0614d5cb41666b742e5721dfe39de3" title="Explicitly trigger a certain analysis. If the host wants to use the plug-in as detection engine,...">requestAudioSourceContentAnalysis()</a> and <a class="el" href="group___model___playback___region.html#a3886d84f7b2a1915afd61ffdca08d8a7" title="Configuration of possible transformations upon playback, i.e. time-stretching etc....">ARAPlaybackRegionProperties::transformationFlags</a>). The host can also optionally instruct the plug-in to run a modal licensing dialog if the current license is not sufficient to perform the selected engine tasks, so that the user can review and adjust the licensing accordingly, such downloading a license from their respective user account or even purchase an upgrade that enables the requested features.  <br>                               The provided content types must be a subset of the plug-in's <a class="el" href="group___plug-_in___factory.html#abdefa00d5ef9074c3563d58265361525" title="Variable-sized C array listing the content types for which the plug-in can perform an analysis....">ARAFactory::analyzeableContentTypes</a>. To request all analysis types exported by the plug-in, hosts can directly pass analyzeableContentTypes and -Count from the <a class="el" href="group___plug-_in___factory.html#struct_a_r_a_factory" title="Static plug-in factory. All pointers herein must remain valid as long as the binary is loaded....">ARAFactory</a>. The contentTypes pointer may be only valid for the duration of the call, it must be evaluated inside the call, and the pointer must not be stored anywhere. If not intending to use analysis, the count should be 0 and the array pointer NULL. The transformationFlags must be a subset of the plug-in's <a class="el" href="group___plug-_in___factory.html#ad86be852472fa25593b8801c4ade263a" title="Set of transformations that the plug-in supports when configuring playback regions....">ARAFactory::supportedPlaybackTransformationFlags</a>, and may be kARAPlaybackTransformationNoChanges if not intending to use transformations. The call returns kARATrue if the (potentially updated) license is sufficient to perform the requested tasks. <br /></td></tr>
<tr class="separator:a44c84dfdd1a2646e6ceb4170c56ba987"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
